[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 720
PlayResY: 576

[Aegisub Project Garbage]
Last Style Storage: LGR翻译
Audio File: 原片.mp4
Video AR Mode: 4
Video AR Value: 1.820988
Video Zoom Percent: 0.750000
Scroll Position: 708
Active Line: 716
Video Position: 77416

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: 底部中文,WenQuanYi Micro Hei,26,&H00FFFFFF,&H000000FF,&H00FF9300,&H00000000,-1,0,0,0,80,120,0,0,1,0.8,0.8,2,10,10,10,1
Style: 顶部说明,WenQuanYi Micro Hei,24,&H00FFFFFF,&H000000FF,&H000090FF,&H00000000,-1,0,0,0,80,120,0,0,1,1.5,0.8,8,10,10,10,1
Style: 顶部注释,WenQuanYi Micro Hei,24,&H00FFFFFF,&H000000FF,&H000090FF,&H00000000,-1,0,0,0,80,120,0,0,1,0.8,0.8,8,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.00,0:00:08.06,顶部说明,,0,0,0,,演讲人: Micheal Steil \N MOS 6502处理器的逆向工程\N 60分钟讲完3510个晶体管
Dialogue: 0,0:00:12.54,0:00:14.42,底部中文,,0,0,0,,欢迎各位！
Dialogue: 0,0:00:16.66,0:00:21.78,底部中文,,0,0,0,,下一场演讲的主题是“MOS 6502处理器的逆向工程”
Dialogue: 0,0:00:21.94,0:00:26.58,底部中文,,0,0,0,,这颗CPU被用在Apple II电脑和NES（美版红白机）以及Commodore 64电脑上
Dialogue: 0,0:00:27.22,0:00:31.18,底部中文,,0,0,0,,现在把话筒交给Micheal Steil
Dialogue: 0,0:00:31.50,0:00:33.22,底部中文,,0,0,0,,他会为你们带来所有的展示
Dialogue: 0,0:00:33.38,0:00:34.46,底部中文,,0,0,0,,谢谢！
Dialogue: 0,0:00:42.14,0:00:42.74,底部中文,,0,0,0,,大家好鸭！
Dialogue: 0,0:00:43.49,0:00:47.50,底部中文,,0,0,0,,刚才你们也知道我演讲的主题是“MOS 6502处理器的逆向工程”
Dialogue: 0,0:00:47.50,0:00:49.62,底部中文,,0,0,0,,我叫Micheal Steil或者Michael Steele（大雾
Dialogue: 0,0:00:47.50,0:00:49.62,顶部说明,,0,0,0,,注：Michael Steele是一名演员，代表作品《坦克战群》《鞭手》
Dialogue: 0,0:00:51.90,0:00:53.06,底部中文,,0,0,0,,有粉丝耶！
Dialogue: 0,0:00:55.66,0:00:59.22,底部中文,,0,0,0,,副标题是“60分钟讲完3510个晶体管”
Dialogue: 0,0:01:00.94,0:01:04.54,底部中文,,0,0,0,,让我先了解一下听众的情况
Dialogue: 0,0:01:04.54,0:01:07.98,底部中文,,0,0,0,,你们有谁写过任何一种架构的汇编语言程序？
Dialogue: 0,0:01:08.98,0:01:10.46,底部中文,,0,0,0,,喔！好吧
Dialogue: 0,0:01:10.70,0:01:13.62,底部中文,,0,0,0,,有谁没有……有谁不知道什么是汇编语言？
Dialogue: 0,0:01:14.86,0:01:16.78,底部中文,,0,0,0,,了解 这样挺好 很有用的信息
Dialogue: 0,0:01:17.14,0:01:19.22,底部中文,,0,0,0,,之前有谁写过6502汇编语言程序？
Dialogue: 0,0:01:20.98,0:01:23.54,底部中文,,0,0,0,,好的 但愿你们在前十分钟不要感到无聊
Dialogue: 0,0:01:24.10,0:01:29.90,底部中文,,0,0,0,,那么有人实现过6502模拟器或者在FPGA上复刻过它吗？
Dialogue: 0,0:01:32.42,0:01:35.06,底部中文,,0,0,0,,一二三……四个人吗？我知道了
Dialogue: 0,0:01:35.66,0:01:39.34,底部中文,,0,0,0,,有人是当年6502设计团队的一员吗？
Dialogue: 0,0:01:45.58,0:01:47.50,底部中文,,0,0,0,,证明在座的各位都是老实人 哈哈
Dialogue: 0,0:01:47.90,0:01:52.66,底部中文,,0,0,0,,介绍给那些不了解历史和6502身世的朋友
Dialogue: 0,0:01:53.70,0:02:00.18,底部中文,,0,0,0,,一群从摩托罗拉跳槽的人于1974年创办了MOS公司
Dialogue: 0,0:02:00.18,0:02:02.90,底部中文,,0,0,0,,这群人之前效力于摩托罗拉的6800处理器项目
Dialogue: 0,0:02:03.10,0:02:10.58,底部中文,,0,0,0,,团队的核心是Chuck Peddle 他是团队的领导人
Dialogue: 0,0:02:10.94,0:02:16.86,底部中文,,0,0,0,,他们在1975年就将6502处理器投放市场
Dialogue: 0,0:02:17.02,0:02:21.90,底部中文,,0,0,0,,它被用在了很多电脑上 图上的人是Steve Jobs和Steve Wozniak
Dialogue: 0,0:02:17.02,0:02:21.90,顶部注释,,0,0,0,,注：乔布斯和沃兹尼亚克是苹果公司的创始人
Dialogue: 0,0:02:23.66,0:02:25.30,底部中文,,0,0,0,,这款CPU在当年非常火
Dialogue: 0,0:02:30.34,0:02:33.14,底部中文,,0,0,0,,它被用在这些系统中
Dialogue: 0,0:02:35.42,0:02:38.42,底部中文,,0,0,0,,Apple I和Apple II以及BBC Micro
Dialogue: 0,0:02:38.42,0:02:44.58,底部中文,,0,0,0,,Commodore的全系列电脑 雅达利所有的8位游戏主机和电脑系统
Dialogue: 0,0:02:38.42,0:02:44.58,顶部说明,,0,0,0,,注：图上第二行从左到右分别是Atari 2600游戏机 Atari 800电脑和山猫LYNX掌机
Dialogue: 0,0:02:44.98,0:02:51.22,底部中文,,0,0,0,,以及任天堂NES 超级任天堂SFC游戏机和……
Dialogue: 0,0:02:53.66,0:02:55.94,底部中文,,0,0,0,,机器人Bender和Flexo！
Dialogue: 0,0:02:53.66,0:02:55.94,顶部注释,,0,0,0,,注：此梗来源于美国喜剧漫画及动画片《飞出个未来》（Futurama）
Dialogue: 0,0:03:01.66,0:03:04.54,底部中文,,0,0,0,,当然也别忘了《终结者》电影里的T-800就是了
Dialogue: 0,0:03:08.10,0:03:13.34,底部中文,,0,0,0,,其他CPU如Z80当然也很成功 相比而言6502有趣在哪呢？
Dialogue: 0,0:03:08.10,0:03:13.34,顶部注释,,0,0,0,,注：Z80是1976年前后美国Zilog公司推出的微处理器
Dialogue: 0,0:03:13.58,0:03:18.46,底部中文,,0,0,0,,对比二者发现6502的晶体管数目少10% 它的设计更优化
Dialogue: 0,0:03:18.46,0:03:21.50,底部中文,,0,0,0,,性能可能不是很强劲 但速度更快
Dialogue: 0,0:03:21.50,0:03:24.58,底部中文,,0,0,0,,约束限制很多的同时也保持着优雅
Dialogue: 0,0:03:25.34,0:03:30.82,底部中文,,0,0,0,,有人曾说优雅和完美来源于简洁嘛
Dialogue: 0,0:03:32.02,0:03:34.30,底部中文,,0,0,0,,我的演讲分为三部分
Dialogue: 0,0:03:34.30,0:03:41.74,底部中文,,0,0,0,,第一部分是“自顶向下的MOS 6502” 主要讲用来和它交互的编程模型
Dialogue: 0,0:03:41.74,0:03:43.06,底部中文,,0,0,0,,但愿大家不要感到无聊
Dialogue: 0,0:03:43.22,0:03:45.26,底部中文,,0,0,0,,第二部分是“自底向上的MOS 6502”
Dialogue: 0,0:03:45.26,0:03:49.98,底部中文,,0,0,0,,讲的是如何“分解”6502 如何观察逻辑门 如何进行（裸片）摄影
Dialogue: 0,0:03:49.98,0:03:52.90,底部中文,,0,0,0,,还有如何从逻辑门层次理解芯片内部发生了什么
Dialogue: 0,0:03:52.90,0:03:56.90,底部中文,,0,0,0,,第三部分是“由内而外”
Dialogue: 0,0:03:56.90,0:04:00.02,底部中文,,0,0,0,,会总结我们在解构6502的过程中学到的东西
Dialogue: 0,0:04:00.70,0:04:03.66,底部中文,,0,0,0,,关于内部组件了解什么 它们是如何交互的
Dialogue: 0,0:04:03.66,0:04:06.62,底部中文,,0,0,0,,还有芯片中一些奇奇怪怪的设计及其由来
Dialogue: 0,0:04:07.42,0:04:11.06,底部中文,,0,0,0,,先来讲第一部分 “自顶向下的MOS 6502”
Dialogue: 0,0:04:12.10,0:04:16.90,底部中文,,0,0,0,,当你学习了解一块新CPU的时候 可能会看数据手册之类的资料
Dialogue: 0,0:04:16.90,0:04:19.38,底部中文,,0,0,0,,我们先不要这样 先来看看它的代码吧
Dialogue: 0,0:04:20.34,0:04:26.58,底部中文,,0,0,0,,针对那些没有见过6502汇编的朋友 先来简单看几条指令
Dialogue: 0,0:04:26.58,0:04:28.66,底部中文,,0,0,0,,STA是保存累加器A用的
Dialogue: 0,0:04:28.66,0:04:30.74,底部中文,,0,0,0,,处理器内部有A X Y三个寄存器
Dialogue: 0,0:04:30.74,0:04:33.74,底部中文,,0,0,0,,JSR是跳转到子程序用的指令（调用指令）
Dialogue: 0,0:04:33.74,0:04:35.54,底部中文,,0,0,0,,LDA用作（将数据）载入累加器A
Dialogue: 0,0:04:35.94,0:04:39.22,底部中文,,0,0,0,,CMP用作比较A寄存器
Dialogue: 0,0:04:39.62,0:04:41.58,底部中文,,0,0,0,,BCC是如果无进位标志则跳转的意思
Dialogue: 0,0:04:41.58,0:04:45.30,底部中文,,0,0,0,,作用是如果小于被比较的数值就跳转执行子程序
Dialogue: 0,0:04:45.30,0:04:52.34,底部中文,,0,0,0,,以及（带进位）加法指令ADC 在其执行前要用CLC清除进位标志 否则进位会被加进去
Dialogue: 0,0:04:52.34,0:04:54.18,底部中文,,0,0,0,,BEQ是如果相等则跳转
Dialogue: 0,0:04:54.18,0:05:00.34,底部中文,,0,0,0,,低级语言编程的另一个趣味点是指令的编码格式
Dialogue: 0,0:05:00.34,0:05:03.70,底部中文,,0,0,0,,首先是操作码 操作码永远是8位长的
Dialogue: 0,0:05:03.70,0:05:09.46,底部中文,,0,0,0,,也就是一个字节的操作码 同时指明了指令和寻址方式
Dialogue: 0,0:05:10.58,0:05:14.06,底部中文,,0,0,0,,操作数可以是0、1或者2字节长
Dialogue: 0,0:05:14.06,0:05:17.74,底部中文,,0,0,0,,比如说CLC清除进位标志指令就没有操作数 是一个单字节指令
Dialogue: 0,0:05:18.02,0:05:22.54,底部中文,,0,0,0,,也可以长达三字节 比如跳转到子程序指令JSR后面就带着一个16位的地址
Dialogue: 0,0:05:22.70,0:05:24.98,底部中文,,0,0,0,,在第一行你能发现一件有趣的事
Dialogue: 0,0:05:25.14,0:05:28.54,底部中文,,0,0,0,,就是这个STA $54 它把一些东西保存到内存中
Dialogue: 0,0:05:28.54,0:05:32.50,底部中文,,0,0,0,,内存地址是16位的 或者说地址总线宽度是16位的
Dialogue: 0,0:05:32.50,0:05:35.02,底部中文,,0,0,0,,但这里（只用了8位表示）是因为目标地址在内存的首页（零页）中
Dialogue: 0,0:05:32.50,0:05:35.02,顶部注释,,0,0,0,,注：操作码85在说明这是一条存累加器指令的同时规定了其寻址方式为零页寻址
Dialogue: 0,0:05:35.02,0:05:39.34,底部中文,,0,0,0,,这种编码让指令更短小 甚至执行起来更快
Dialogue: 0,0:05:40.86,0:05:44.86,底部中文,,0,0,0,,如果我们从更加理论的视角来看这个编程模型
Dialogue: 0,0:05:45.18,0:05:47.58,底部中文,,0,0,0,,我们有A寄存器 也叫累加器
Dialogue: 0,0:05:47.82,0:05:50.66,底部中文,,0,0,0,,它可以存放一切数据 也可以用做数据转运
Dialogue: 0,0:05:50.66,0:05:56.38,底部中文,,0,0,0,,当你处理数据的时候 比如做算术和逻辑运算 数据都会经由这个A寄存器
Dialogue: 0,0:05:56.38,0:05:58.98,底部中文,,0,0,0,,还有索引寄存器（X和Y） 它们也很强大
Dialogue: 0,0:05:56.38,0:05:58.98,顶部注释,,0,0,0,,注：索引寄存器也叫变址寄存器，索引数组的本质就是变址寻址
Dialogue: 0,0:05:58.98,0:06:00.06,底部中文,,0,0,0,,它们有自增和自减操作
Dialogue: 0,0:06:00.06,0:06:03.98,底部中文,,0,0,0,,可以被用作访问数组的索引
Dialogue: 0,0:06:03.98,0:06:06.34,底部中文,,0,0,0,,但你不能直接用它们做算术和逻辑运算
Dialogue: 0,0:06:07.10,0:06:09.70,底部中文,,0,0,0,,还有这个8位的处理器状态寄存器
Dialogue: 0,0:06:09.70,0:06:13.14,底部中文,,0,0,0,,其中的这四位是与算术和逻辑运算（结果）相关的（标志位）
Dialogue: 0,0:06:13.46,0:06:18.46,底部中文,,0,0,0,,这一位是用来指示十进制模式（开启与否）的 我们稍后再聊
Dialogue: 0,0:06:18.46,0:06:19.90,底部中文,,0,0,0,,可能听起来有点无聊
Dialogue: 0,0:06:20.46,0:06:24.30,底部中文,,0,0,0,,剩下这两位是与异常和中断处理有关的
Dialogue: 0,0:06:20.46,0:06:22.58,顶部注释,,0,0,0,,注：由于一般外部中断IRQ和软中断BRK这两个中断优先级相同且共用同一个中断向量和中断服务\N程序，B（软中断）标志在软中断发生后自动置位，用来让服务程序判断发生的是IRQ还是BRK\N
Dialogue: 0,0:06:22.70,0:06:24.30,顶部注释,,0,0,0,,注：I（禁止中断）标志在IRQ或BRK发生后自动置1，用来屏蔽IRQ（不能屏蔽BRK），\N不可屏蔽中断NMI不改变I标志
Dialogue: 0,0:06:25.70,0:06:31.46,底部中文,,0,0,0,,还有16位的程序计数器（又叫做指令指针IP）
Dialogue: 0,0:06:31.86,0:06:35.54,底部中文,,0,0,0,,这个是16位的堆栈指针 也只能存放地址
Dialogue: 0,0:06:35.54,0:06:41.18,底部中文,,0,0,0,,但高八位是固定的 它们被硬编码为0x01 所以实际上只有8位可用
Dialogue: 0,0:06:42.30,0:06:46.18,底部中文,,0,0,0,,编程模型中还有一点没讲到 那就是内存地址空间
Dialogue: 0,0:06:47.50,0:06:52.90,底部中文,,0,0,0,,我们一共能寻址到64KB的内存 但前两页（每页256字节）比较特殊
Dialogue: 0,0:06:52.90,0:06:56.22,底部中文,,0,0,0,,首页也就是第零页被称作“零页”
Dialogue: 0,0:06:52.90,0:06:56.22,顶部注释,,0,0,0,,注：从0开始计数几乎是计算机领域的一种习惯
Dialogue: 0,0:06:56.22,0:06:57.70,底部中文,,0,0,0,,它一直延伸到0x00FF
Dialogue: 0,0:06:57.70,0:07:00.38,底部中文,,0,0,0,,它牵扯到寻址模式
Dialogue: 0,0:07:00.38,0:07:06.94,底部中文,,0,0,0,,如果你要寻址的内存在零页中 就可以用特殊指令编码 速度更快
Dialogue: 0,0:07:06.94,0:07:14.42,底部中文,,0,0,0,,有些事是只有零页可以完成的 因为系统设计上有寄存器的局限（数量少）
Dialogue: 0,0:07:14.42,0:07:17.62,底部中文,,0,0,0,,（真正可以用来存储数据的）只有累加器 这时候零页就很有用了
Dialogue: 0,0:07:17.62,0:07:25.18,底部中文,,0,0,0,,堆栈固定使用第一页 也就是0x00FF-0x01FF的地址空间
Dialogue: 0,0:07:26.46,0:07:29.34,底部中文,,0,0,0,,看看这张复杂到让人眼花缭乱的幻灯片
Dialogue: 0,0:07:29.58,0:07:36.30,底部中文,,0,0,0,,它会给出所有（官方）指令并把它们分类
Dialogue: 0,0:07:36.30,0:07:38.34,底部中文,,0,0,0,,在图上很多地方能看到注记（分类依据）
Dialogue: 0,0:07:38.34,0:07:43.58,底部中文,,0,0,0,,你可能没学过它们 但不需要都记下来
Dialogue: 0,0:07:43.58,0:07:44.74,底部中文,,0,0,0,,这几个是装载指令
Dialogue: 0,0:07:44.74,0:07:47.86,底部中文,,0,0,0,,你可以把内存数据装入累加器或X/Y寄存器
Dialogue: 0,0:07:48.26,0:07:51.82,底部中文,,0,0,0,,如果要把数据（从寄存器）保存到内存 就使用STA STX和STY指令
Dialogue: 0,0:07:51.82,0:07:53.98,底部中文,,0,0,0,,你可以（用这六个）指令在寄存器间转移数据
Dialogue: 0,0:07:51.82,0:07:53.98,顶部注释,,0,0,0,,注：如TAX就是将累加器内容送到X寄存器
Dialogue: 0,0:07:53.98,0:07:57.78,底部中文,,0,0,0,,还有两组读-修改-写（RMW）指令
Dialogue: 0,0:07:58.30,0:08:01.94,底部中文,,0,0,0,,有（四个）和累加器搭配使用的移位指令
Dialogue: 0,0:07:58.30,0:08:01.94,顶部注释,,0,0,0,,注：ASL算术左移，LSR逻辑右移，ROL循环左移，ROR循环右移\N非循环移位均是零扩充，移出的位进入进位标志中
Dialogue: 0,0:08:01.94,0:08:10.14,底部中文,,0,0,0,,也可以对内存变量进行自增/自减 索引寄存器X/Y也是一样 这一点非常重要
Dialogue: 0,0:08:01.94,0:08:10.14,顶部注释,,0,0,0,,注：DEC对内存变量自减，DEX对X寄存器自减
Dialogue: 0,0:08:12.54,0:08:16.02,底部中文,,0,0,0,,算术逻辑单元ALU可以进行的操作有算术加法和减法
Dialogue: 0,0:08:12.54,0:08:16.02,顶部注释,,0,0,0,,注：ADC带进/借位标志的加法，SBC带进/借位标志的减法
Dialogue: 0,0:08:16.66,0:08:19.26,底部中文,,0,0,0,,还有布尔逻辑运算
Dialogue: 0,0:08:16.66,0:08:19.26,顶部注释,,0,0,0,,注：AND与运算，ORA或运算，EOR异或运算\N第一个操作数永远是累加器，第二个操作数是内存变量，结果存放在累加器中
Dialogue: 0,0:08:19.26,0:08:21.90,底部中文,,0,0,0,,还有两组特殊的运算指令
Dialogue: 0,0:08:21.90,0:08:27.62,底部中文,,0,0,0,,比较命令基本上是只保存标志位而不保存结果的减法指令
Dialogue: 0,0:08:21.90,0:08:27.62,顶部注释,,0,0,0,,注：CMP为累加器与内存变量比较，CPX/Y为X/Y寄存器与内存变量比较\N比较指令组根据减法结果改变N（负数）、Z（零）和C（进位/无符号溢出）标志
Dialogue: 0,0:08:27.62,0:08:32.70,底部中文,,0,0,0,,位测试指令BIT是只保存标志位而不保存运算结果的逻辑与运算指令
Dialogue: 0,0:08:27.62,0:08:32.70,顶部注释,,0,0,0,,注：BIT指令根据按位与运算结果是否为零影响Z（零）标志\N同时将结果的位6存入V（符号数溢出）标志，位7存入N（负数）标志
Dialogue: 0,0:08:33.22,0:08:36.46,底部中文,,0,0,0,,说起标志位 你可以（用这七条指令）设置或清除一些标志位
Dialogue: 0,0:08:33.22,0:08:36.46,顶部注释,,0,0,0,,注：例如SEC设置进位标志，CLC清除进位标志
Dialogue: 0,0:08:37.50,0:08:42.14,底部中文,,0,0,0,,你还可以根据标志位设置或清除的情况来进行条件跳转
Dialogue: 0,0:08:37.50,0:08:42.14,顶部注释,,0,0,0,,注：用N（负数）标志判断：BMI（结果为负则跳转）和BPL（结果为正则跳转）\N用V（符号数溢出）标志判断：BVS（溢出标志设定则跳转）和BVC（溢出标志清除则跳转）
Dialogue: 0,0:08:42.14,0:08:48.18,底部中文,,0,0,0,,其依据的是处理器状态寄存器中四个与算术逻辑运算有关的标志位
Dialogue: 0,0:08:42.14,0:08:48.18,顶部注释,,0,0,0,,注：用Z（零）标志判断：BEQ（相等则跳转）和BNE（不相等则跳转）\N用C（进位）标志判断：BCS（进位标志设定则跳转）和BCC（进位标志清除则跳转）
Dialogue: 0,0:08:49.70,0:08:51.90,底部中文,,0,0,0,,还有无条件跳转指令JMP
Dialogue: 0,0:08:51.90,0:08:55.62,底部中文,,0,0,0,,JSR用作子程序（函数）调用 RTS用作子程序返回
Dialogue: 0,0:08:55.98,0:09:05.18,底部中文,,0,0,0,,软中断和子程序调用类似 BRK用作软中断触发 RTI用作中断返回
Dialogue: 0,0:08:55.98,0:09:05.18,顶部注释,,0,0,0,,注：可以看到JSR/RTS和BRK/RTI都与堆栈操作有关（保存原PC和状态寄存器用）\N而JMP不涉及堆栈操作（只是跳转）
Dialogue: 0,0:09:05.58,0:09:12.86,底部中文,,0,0,0,,你只可以对A寄存器和状态寄存器进行栈操作
Dialogue: 0,0:09:05.58,0:09:12.86,顶部注释,,0,0,0,,注：PHA压入累加器（到堆栈），PLA（从堆栈）弹出到累加器\NPHP压入状态寄存器（到堆栈），PLP（从堆栈）弹出到状态寄存器
Dialogue: 0,0:09:13.74,0:09:15.70,底部中文,,0,0,0,,以上就是所有现有的指令了
Dialogue: 0,0:09:15.70,0:09:20.82,底部中文,,0,0,0,,对于用用指令 以下寻址模式可以和它们搭配使用
Dialogue: 0,0:09:15.70,0:09:20.82,顶部注释,,0,0,0,,注：在汇编语言里，不同寻址模式的同一个指令用相同的助记符表示，\N但操作数的表示方式不同，对应机器语言的操作码也不同
Dialogue: 0,0:09:20.82,0:09:23.74,底部中文,,0,0,0,,有使用常数的立即数寻址
Dialogue: 0,0:09:23.90,0:09:27.62,底部中文,,0,0,0,,绝对寻址和绝对X/Y变址寻址
Dialogue: 0,0:09:27.62,0:09:29.62,底部中文,,0,0,0,,这种（绝对寻址和绝对X/Y变址寻址）同样适用于零页方式
Dialogue: 0,0:09:29.62,0:09:36.26,底部中文,,0,0,0,,最后两种特殊的零页寻址方式用于弥补（处理器设计上的）不足和局限
Dialogue: 0,0:09:37.10,0:09:42.46,底部中文,,0,0,0,,寻址模式很重要 我快速讲一下
Dialogue: 0,0:09:42.46,0:09:45.46,底部中文,,0,0,0,,带#号的是立即数寻址
Dialogue: 0,0:09:45.46,0:09:49.82,底部中文,,0,0,0,,在这里你可以用LDA把一个常数载入累加器中
Dialogue: 0,0:09:49.82,0:09:53.26,底部中文,,0,0,0,,这样就把常数0x17装入累加器了
Dialogue: 0,0:09:49.82,0:09:53.26,顶部注释,,0,0,0,,注：6502汇编用$表示十六进制；字幕中用0x前缀表示十六进制，十进制不做特殊说明
Dialogue: 0,0:09:54.26,0:09:57.94,底部中文,,0,0,0,,绝对寻址使用一个16位的操作数
Dialogue: 0,0:09:58.58,0:10:02.62,底部中文,,0,0,0,,我们从0x0314这个地方载入一个数 先找到内存的0x0314这个地址
Dialogue: 0,0:10:02.62,0:10:05.54,底部中文,,0,0,0,,里面存的是0x31 这样累加器A里面就有了0x31这个数
Dialogue: 0,0:10:06.42,0:10:09.18,底部中文,,0,0,0,,零页寻址是（对绝对寻址的）一个优化
Dialogue: 0,0:10:09.46,0:10:12.50,底部中文,,0,0,0,,编码方式不同 操作数只有8位
Dialogue: 0,0:10:12.50,0:10:18.66,底部中文,,0,0,0,,我们从0x02这个地方读取 零页中0x0002存放的是0 因此A里面就存入了0
Dialogue: 0,0:10:19.86,0:10:23.22,底部中文,,0,0,0,,绝对X变址寻址意味着内存变量的地址是绝对地址+X
Dialogue: 0,0:10:23.22,0:10:28.66,底部中文,,0,0,0,,X索引寄存器的内容会加上一个在指令中硬编码的常数指针
Dialogue: 0,0:10:29.70,0:10:33.06,底部中文,,0,0,0,,所以在我们的例子里是0x0200加上X的内容 X里面是0x0A
Dialogue: 0,0:10:33.06,0:10:35.66,底部中文,,0,0,0,,也就是我们要从地址0x020A读数据
Dialogue: 0,0:10:37.10,0:10:39.14,底部中文,,0,0,0,,查一下0x020A这个内存地址 里面是0x52
Dialogue: 0,0:10:39.14,0:10:44.46,底部中文,,0,0,0,,假设内存在0x0200这个地方存放着一个字节数组 用X就能访问其中每一个元素
Dialogue: 0,0:10:45.62,0:10:48.14,底部中文,,0,0,0,,绝对Y变址寻址是一样的 只不过换成了Y索引寄存器
Dialogue: 0,0:10:48.14,0:10:50.90,底部中文,,0,0,0,,对称性很强
Dialogue: 0,0:10:50.97,0:10:52.50,底部中文,,0,0,0,,零页变址寻址也相仿
Dialogue: 0,0:10:52.50,0:10:57.38,底部中文,,0,0,0,,不过有趣的是这种寻址会在零页内部循环
Dialogue: 0,0:10:57.38,0:11:05.34,底部中文,,0,0,0,,在这个例子中如果X大于等于16 地址会回到0x0000 并不会超出零页
Dialogue: 0,0:10:57.38,0:11:03.58,顶部注释,,0,0,0,,注：即0xF0+0x0F(15)=0xFF，0xF0+0x10(16)=0x00（零页内首尾循环）
Dialogue: 0,0:11:05.57,0:11:08.82,底部中文,,0,0,0,,零页Y变址寻址也是同样的道理
Dialogue: 0,0:11:09.50,0:11:11.90,底部中文,,0,0,0,,还有两种有趣的间接寻址方式
Dialogue: 0,0:11:09.50,0:11:11.90,顶部注释,,0,0,0,,注：间接寻址，和直接寻址相对，即第一次从内存中读出的是地址，\N使用该地址再读一次内存才能读到最终数据
Dialogue: 0,0:11:11.90,0:11:15.82,底部中文,,0,0,0,,我们之前说过 6502并没有一个16位的寄存器（PC除外）
Dialogue: 0,0:11:15.82,0:11:19.86,底部中文,,0,0,0,,如果我们有一个16位的指针怎么办？你没法把它放在寄存器里
Dialogue: 0,0:11:15.82,0:11:19.86,顶部注释,,0,0,0,,注：6502的三个通用数据寄存器A/X/Y是8位的，因为其数据总线宽度是8位（ALU也是）\N但为了让其读写更大的内存，地址总线宽度设计为16位
Dialogue: 0,0:11:19.86,0:11:21.78,底部中文,,0,0,0,,这一点和Z80这些处理器有很大差别
Dialogue: 0,0:11:22.26,0:11:30.46,底部中文,,0,0,0,,所以将这些指针存放在零页中 并在指令中把零页当成指针来用 就像是这样
Dialogue: 0,0:11:31.10,0:11:37.30,底部中文,,0,0,0,,第一种寻址模式叫做“先变址X后间址”
Dialogue: 0,0:11:31.10,0:11:35.22,顶部注释,,0,0,0,,注：“变址”即对地址做加减，用逗号跟上变址寄存器
Dialogue: 0,0:11:35.78,0:11:37.30,顶部注释,,0,0,0,,注：“间址（间接寻址）”即用地址读内存得到指针，用该指针再读一次内存得到数据\N一对括号表示间接寻址，(addr)表示addr处存放的是指针
Dialogue: 0,0:11:37.46,0:11:44.26,底部中文,,0,0,0,,在这里假设零页的0x0080处存放有一个指针数组
Dialogue: 0,0:11:44.78,0:11:46.58,底部中文,,0,0,0,,我们用X寄存器来索引这个数组
Dialogue: 0,0:11:46.74,0:11:49.26,底部中文,,0,0,0,,然后从数组的相应位置拿到一个指针
Dialogue: 0,0:11:49.90,0:11:58.26,底部中文,,0,0,0,,在这里处理器会访问内存0x008C（X存放有索引0x0C）并取得一个指针
Dialogue: 0,0:11:58.26,0:12:01.14,底部中文,,0,0,0,,众所周知6502使用小端模式（所以合成一个指针0xC43F）
Dialogue: 0,0:11:58.26,0:12:01.14,顶部注释,,0,0,0,,注：小端模式即一次性存放长于数据总线宽度的数据到内存时，低位在前（低地址处）
Dialogue: 0,0:12:01.78,0:12:04.42,底部中文,,0,0,0,,然后从0xC43F载入数据
Dialogue: 0,0:12:05.18,0:12:07.78,底部中文,,0,0,0,,再读一次内存 把读到的内容载入寄存器A
Dialogue: 0,0:12:07.78,0:12:12.14,底部中文,,0,0,0,,由于是“双间接”的 执行更慢一些 大概要五六个周期
Dialogue: 0,0:12:07.78,0:12:12.14,顶部注释,,0,0,0,,注：先要算变化后的地址，再间接寻址
Dialogue: 0,0:12:13.42,0:12:15.30,底部中文,,0,0,0,,还有一种一样的 准确来说不一样的寻址方式
Dialogue: 0,0:12:15.30,0:12:18.90,底部中文,,0,0,0,,区别是后者叫“后变址Y间址” 先用零页间接寻址（拿到指针） 再用Y索引
Dialogue: 0,0:12:18.90,0:12:21.86,底部中文,,0,0,0,,这种寻址方式要实用得多
Dialogue: 0,0:12:22.30,0:12:27.14,底部中文,,0,0,0,,因为它把零页中0x0014和0x0015的内容当成一个16位的指针
Dialogue: 0,0:12:27.46,0:12:30.94,底部中文,,0,0,0,,这里0x0014和0x0015存放的指针是0xD800
Dialogue: 0,0:12:30.94,0:12:36.06,底部中文,,0,0,0,,之后加上Y的内容 也就是0x28 最终从0xD828读数据
Dialogue: 0,0:12:37.18,0:12:44.06,底部中文,,0,0,0,,如果需要向上访问（数组）只要事先将首地址存入零页 之后便不用关心具体地址
Dialogue: 0,0:12:45.34,0:12:46.78,底部中文,,0,0,0,,堆栈不怎么需要寻址
Dialogue: 0,0:12:47.14,0:12:48.90,底部中文,,0,0,0,,其指令的寻址模式是隐含的
Dialogue: 0,0:12:49.46,0:12:53.70,底部中文,,0,0,0,,堆栈的工作模式是这样的 你需要将堆栈指针S初始化为0xFF
Dialogue: 0,0:12:49.46,0:12:53.70,顶部注释,,0,0,0,,注：堆栈指针寄存器S可用八位，堆栈空间地址高八位被固定为0x01，\N最大可用栈空间只有256字节（0x0100-0x01FF），且位置不能改变
Dialogue: 0,0:12:54.70,0:12:58.66,底部中文,,0,0,0,,如果向堆栈里压入数据 会先存入数据 之后堆栈指针S自减
Dialogue: 0,0:12:54.70,0:12:58.66,顶部注释,,0,0,0,,注：这与x86等指令集架构的入栈顺序不同，但相同的是栈都从高地址向低地址生长
Dialogue: 0,0:12:58.66,0:13:04.18,底部中文,,0,0,0,,我们再压入一点别的 先将其存入堆栈指针S指向的地方 之后S减1
Dialogue: 0,0:13:05.58,0:13:09.78,底部中文,,0,0,0,,如果我们做一次出栈 S先自增 再从指向的地方取出数据
Dialogue: 0,0:13:09.78,0:13:12.34,底部中文,,0,0,0,,再来一次 堆栈指针自增 然后读取
Dialogue: 0,0:13:13.74,0:13:19.58,底部中文,,0,0,0,,接下来讲十进制模式 我想大概只有70年代或80年代的人才能完全理解这东西
Dialogue: 0,0:13:13.74,0:13:19.58,顶部注释,,0,0,0,,注：十进制模式把十六进制数限制处理当成十进制使用，省去十进制转换子程序，提高系统速度
Dialogue: 0,0:13:19.58,0:13:23.38,底部中文,,0,0,0,,那群人用Commodore或Atari电脑做金融工作
Dialogue: 0,0:13:23.86,0:13:37.54,底部中文,,0,0,0,,十进制模式也就是BCD（用二进制编码的十进制数）模式 用来优化整数的存储及打印
Dialogue: 0,0:13:38.22,0:13:43.66,底部中文,,0,0,0,,一般情况下 如果将9与2相加会得到十六进制的“B”
Dialogue: 0,0:13:43.66,0:13:49.54,底部中文,,0,0,0,,但如果将十进制模式打开 指令执行并不会变慢
Dialogue: 0,0:13:50.06,0:13:58.42,底部中文,,0,0,0,,得到一个十六进制的0x11 以二进制加法是错的 但从十进制角度看合乎常理
Dialogue: 0,0:13:59.98,0:14:05.18,底部中文,,0,0,0,,以上都是比较贴近用户的东西 而从系统的层面来看
Dialogue: 0,0:14:05.18,0:14:09.06,底部中文,,0,0,0,,这些中断向量值得关注 它们揭示了中断、复位和外部IRQ中断请求的工作方式
Dialogue: 0,0:14:09.06,0:14:11.38,底部中文,,0,0,0,,内存地址空间的顶部存放着三个中断向量
Dialogue: 0,0:14:11.38,0:14:16.58,底部中文,,0,0,0,,对应着不可屏蔽中断NMI 复位RESET 和一般外部中断IRQ的向量
Dialogue: 0,0:14:11.38,0:14:16.58,顶部注释,,0,0,0,,注：中断向量就是中断服务程序的入口地址；中断优先级RESET>NMI>IRQ/BRK
Dialogue: 0,0:14:17.74,0:14:22.06,底部中文,,0,0,0,,我们稍后再讨论这些中断向量 它们很有趣
Dialogue: 0,0:14:22.38,0:14:25.46,底部中文,,0,0,0,,来看一下现有的所有指令
Dialogue: 0,0:14:25.46,0:14:27.54,底部中文,,0,0,0,,再来看看现有的所有寻址方式
Dialogue: 0,0:14:27.54,0:14:35.22,底部中文,,0,0,0,,我们将二者组合 如果处理器是完全正交（每一种通用指令都能搭配任一寻址方式）
Dialogue: 0,0:14:35.62,0:14:39.26,底部中文,,0,0,0,,即便这样都无法填满全部256种不同的操作码
Dialogue: 0,0:14:39.66,0:14:43.26,底部中文,,0,0,0,,芯片设计者所做的是将那些非常有用的指令编码
Dialogue: 0,0:14:43.26,0:14:46.98,底部中文,,0,0,0,,也就是这些开发人员最感兴趣 最重要的指令
Dialogue: 0,0:14:46.98,0:14:49.38,底部中文,,0,0,0,,这些只用掉了操作码空间的60%
Dialogue: 0,0:14:50.50,0:14:52.98,底部中文,,0,0,0,,而那些其他的指令他们只是说“未定义”
Dialogue: 0,0:14:54.70,0:14:57.66,底部中文,,0,0,0,,再快速浏览一个例子吧
Dialogue: 0,0:14:58.14,0:15:01.50,底部中文,,0,0,0,,这段代码是随便从某一块随机ROM（只读存储器）里找到的
Dialogue: 0,0:15:01.50,0:15:03.94,底部中文,,0,0,0,,你有可能看过这段代码 也可能用过它
Dialogue: 0,0:15:04.26,0:15:06.90,底部中文,,0,0,0,,我们从零页里载入某个内存变量（的低八位）
Dialogue: 0,0:15:06.90,0:15:08.74,底部中文,,0,0,0,,把它和常数比较
Dialogue: 0,0:15:08.74,0:15:11.30,底部中文,,0,0,0,,如果和那个常数不相等 就跳出这个片段（到标号14）
Dialogue: 0,0:15:11.46,0:15:14.66,底部中文,,0,0,0,,然后载入这个变量的高八位
Dialogue: 0,0:15:14.66,0:15:16.50,底部中文,,0,0,0,,同样和一个常数比较
Dialogue: 0,0:15:17.02,0:15:20.02,底部中文,,0,0,0,,如果不是6502这个常数 就跳出程序片段（到标号14）
Dialogue: 0,0:15:20.38,0:15:26.10,底部中文,,0,0,0,,否则减法的结果0被存入A寄存器 之后我们将这个0存入0x0011
Dialogue: 0,0:15:26.30,0:15:28.46,底部中文,,0,0,0,,再把0拷贝到Y寄存器中
Dialogue: 0,0:15:29.90,0:15:32.06,底部中文,,0,0,0,,我们往A寄存器中装载立即数0x80 并把它存入内存0x0012处
Dialogue: 0,0:15:32.06,0:15:35.22,底部中文,,0,0,0,,这样我们在内存0x0011-0x0012处就有了指针0x8000
Dialogue: 0,0:15:36.86,0:15:40.82,底部中文,,0,0,0,,我们给索引寄存器（X）装入立即数0x0A
Dialogue: 0,0:15:40.82,0:15:43.50,底部中文,,0,0,0,,也就是十进制数10 从某处递减计数10次
Dialogue: 0,0:15:43.50,0:15:46.46,底部中文,,0,0,0,,同时以X寄存器为索引从ROM里面读一些东西
Dialogue: 0,0:15:46.62,0:15:49.62,底部中文,,0,0,0,,这样就达成了从第十个元素开始向下访问数组的目的
Dialogue: 0,0:15:50.70,0:15:52.26,底部中文,,0,0,0,,然后使用掩码（与A进行逻辑与）清除一些不需要的位
Dialogue: 0,0:15:53.06,0:15:56.18,底部中文,,0,0,0,,将累加器内容存放在内存中0x8000+Y的地方
Dialogue: 0,0:15:53.06,0:15:56.18,顶部注释,,0,0,0,,注：$11处就是刚才存入的指针0x8000
Dialogue: 0,0:15:56.54,0:15:57.38,底部中文,,0,0,0,,让Y寄存器自增
Dialogue: 0,0:15:57.38,0:15:59.94,底部中文,,0,0,0,,如果没有Y没有溢出 就跳过下一条指令（到标号13）
Dialogue: 0,0:15:57.38,0:15:59.94,顶部注释,,0,0,0,,注：无符号溢出后变为0，Z标志置位，所以用BNE判断
Dialogue: 0,0:15:59.94,0:16:03.94,底部中文,,0,0,0,,否则就让（0x0012处的）0x80自增变成0x81
Dialogue: 0,0:16:04.70,0:16:08.26,底部中文,,0,0,0,,让X索引寄存器自减 也就是从10计数到0
Dialogue: 0,0:16:09.06,0:16:13.58,底部中文,,0,0,0,,然后让内存中存放循环次数的参数自减
Dialogue: 0,0:16:13.58,0:16:17.14,底部中文,,0,0,0,,之后跳转（到标号11）来循环 （若循环结束）就用RTS做调用返回
Dialogue: 0,0:16:17.42,0:16:22.42,底部中文,,0,0,0,,我们可以看到参数被存放在零页的0x0011、 0x0012和0x0046处
Dialogue: 0,0:16:22.70,0:16:24.70,底部中文,,0,0,0,,我们对零页做了大量操作
Dialogue: 0,0:16:24.98,0:16:26.62,底部中文,,0,0,0,,可是这段代码是干什么的呢？
Dialogue: 0,0:16:27.42,0:16:31.78,底部中文,,0,0,0,,如果你用过Commodore PET电脑的某一后期型号的话
Dialogue: 0,0:16:32.64,0:16:38.50,底部中文,,0,0,0,,在命令行下执行这条命令 WAIT命令是合法的 它会做一些有趣的事
Dialogue: 0,0:16:38.50,0:16:42.82,底部中文,,0,0,0,,如果使用了常数6502 结果是这样的
Dialogue: 0,0:16:38.50,0:16:42.82,顶部注释,,0,0,0,,注：注意左上角出现字符串"MICROSOFT!"盖住了一部分"COMMODORE"字样
Dialogue: 0,0:16:44.98,0:16:45.82,底部中文,,0,0,0,,怎么会这样呢？
Dialogue: 0,0:16:45.82,0:16:48.38,底部中文,,0,0,0,,因为这是是比尔·盖茨干的
Dialogue: 0,0:16:49.70,0:16:53.38,底部中文,,0,0,0,,微软和Commodore有授权关系 微软给PET电脑写了BASIC解释器
Dialogue: 0,0:16:53.38,0:16:56.34,底部中文,,0,0,0,,后来Commodore找微软索要修复好漏洞的版本给新版PET电脑用
Dialogue: 0,0:16:56.34,0:16:59.62,底部中文,,0,0,0,,微软当时气疯了 Commodore对于微软给他们开发软件的事儿闭口不言
Dialogue: 0,0:16:59.62,0:17:01.62,底部中文,,0,0,0,,屏幕上面写的是“COMMODORE BASIC”
Dialogue: 0,0:17:01.62,0:17:03.50,底部中文,,0,0,0,,这就是这个复活节彩蛋的由来
Dialogue: 0,0:17:03.90,0:17:09.22,底部中文,,0,0,0,,我们非常确定这段代码是比尔·盖茨写的
Dialogue: 0,0:17:09.22,0:17:13.74,底部中文,,0,0,0,,因为在当时 也就是1976-1977年 微软只有三名雇员
Dialogue: 0,0:17:13.74,0:17:18.22,底部中文,,0,0,0,,其中一个人不会编程 另一个人是写Z80代码的 所以嘛……
Dialogue: 0,0:17:19.22,0:17:22.06,底部中文,,0,0,0,,因此比尔·盖茨在某种程度上也是6502开发者
Dialogue: 0,0:17:22.94,0:17:26.30,底部中文,,0,0,0,,关于8位架构你可能还对这个感兴趣
Dialogue: 0,0:17:26.30,0:17:31.66,底部中文,,0,0,0,,你应该了解指令的机器周期数 除了优化程序 更多的是为了认识处理器做了什么
Dialogue: 0,0:17:32.22,0:17:34.70,底部中文,,0,0,0,,每一次内存访问都要用掉一个周期
Dialogue: 0,0:17:34.70,0:17:36.46,底部中文,,0,0,0,,整套系统操作和内存访问息息相关
Dialogue: 0,0:17:36.46,0:17:43.90,底部中文,,0,0,0,,基本上只要知道指令执行过程中进行了几次内存访问 就知道这条指令的周期数了
Dialogue: 0,0:17:43.90,0:17:47.86,底部中文,,0,0,0,,当然也有特例 那就是每条指令至少用掉两个周期
Dialogue: 0,0:17:48.30,0:17:49.66,底部中文,,0,0,0,,再快速过一遍这个例子
Dialogue: 0,0:17:49.86,0:17:55.38,底部中文,,0,0,0,,一个零页寻址的LDA指令花掉三个周期 因为要取指令 取操作数 最后读零页
Dialogue: 0,0:17:55.38,0:17:59.34,底部中文,,0,0,0,,比较指令花掉两个周期 因为指令至少花两个周期 而它不需要做额外的内存读取
Dialogue: 0,0:17:59.62,0:18:02.18,底部中文,,0,0,0,,这个（BNE）同样花掉两个周期 因为它是一条双字节指令
Dialogue: 0,0:18:02.18,0:18:05.66,底部中文,,0,0,0,,如果发生了跳转 则要多花一个周期
Dialogue: 0,0:18:06.58,0:18:08.46,底部中文,,0,0,0,,这几条指令同理
Dialogue: 0,0:18:08.70,0:18:14.30,底部中文,,0,0,0,,这条转移指令（TAY）是单字节指令 但还是花掉最少的两个周期
Dialogue: 0,0:18:15.06,0:18:17.46,底部中文,,0,0,0,,这一条就有点意思了
Dialogue: 0,0:18:17.94,0:18:22.18,底部中文,,0,0,0,,取指令（LDA）和两个操作数（16位的地址）进行了三次内存访问
Dialogue: 0,0:18:22.18,0:18:25.58,底部中文,,0,0,0,,最后一次从内存读出数据 这样就花费四个周期了
Dialogue: 0,0:18:25.58,0:18:32.66,底部中文,,0,0,0,,但变址的时候（低八位）如果发生了溢出 也就是从xE0页切换到xE1页
Dialogue: 0,0:18:32.66,0:18:38.14,底部中文,,0,0,0,,ALU就会多做一步用来处理向高八位的进位 这样就会用掉五个周期
Dialogue: 0,0:18:38.70,0:18:42.58,底部中文,,0,0,0,,剩下的大概浏览一下就可以了 更复杂的操作花费六个周期
Dialogue: 0,0:18:42.90,0:18:44.62,底部中文,,0,0,0,,零页变量自增用掉五个周期
Dialogue: 0,0:18:45.50,0:18:49.06,底部中文,,0,0,0,,RTS和JSR指令是真正的“性能杀手”
Dialogue: 0,0:18:49.06,0:18:52.58,底部中文,,0,0,0,,一对用作子程序调用和返回的JSR和RTS指令一共会浪费掉十二个周期
Dialogue: 0,0:18:54.26,0:18:58.38,底部中文,,0,0,0,,6502还有一些奇葩的东西
Dialogue: 0,0:18:58.54,0:19:02.86,底部中文,,0,0,0,,有些被视作漏洞 有些你可能不会在乎其产生原因
Dialogue: 0,0:19:02.86,0:19:08.42,底部中文,,0,0,0,,比如说 当自增一个内存变量的时候 你觉得应该读一次内存 再写一次内存
Dialogue: 0,0:19:08.42,0:19:14.98,底部中文,,0,0,0,,但实际上处理器会读出变量 先用4-6个周期原封不动地写回去
Dialogue: 0,0:19:14.98,0:19:17.42,底部中文,,0,0,0,,最后才会写入自增后的新值
Dialogue: 0,0:19:17.42,0:19:20.38,底部中文,,0,0,0,,从软件角度 这两种方式并没有什么不同
Dialogue: 0,0:19:20.38,0:19:22.34,底部中文,,0,0,0,,但从硬件角度 这种差异是可测量的
Dialogue: 0,0:19:22.34,0:19:27.30,底部中文,,0,0,0,,你甚至可以利用它 把这种奇怪的特性用在计算机系统构建中去
Dialogue: 0,0:19:27.30,0:19:31.38,底部中文,,0,0,0,,设计一种防拷贝机制或围绕它设计一些其他应用
Dialogue: 0,0:19:32.14,0:19:33.54,底部中文,,0,0,0,,另外一点就是漏洞实锤了
Dialogue: 0,0:19:34.34,0:19:38.02,底部中文,,0,0,0,,如果你使用BRK指令 当然实际应用中可能用不到
Dialogue: 0,0:19:38.02,0:19:43.54,底部中文,,0,0,0,,但在调试器里它常被用作调试用途 如果想知道程序流向 不妨插入一个BRK
Dialogue: 0,0:19:43.82,0:19:46.78,底部中文,,0,0,0,,但如果在实际代码里有BRK 而不巧同时一个（硬件）中断产生
Dialogue: 0,0:19:47.50,0:19:52.18,底部中文,,0,0,0,,那么这个BRK会丢失 硬件中断服务程序返回后BRK不会发生
Dialogue: 0,0:19:53.46,0:19:57.46,底部中文,,0,0,0,,在图上非法操作码处有个大问号
Dialogue: 0,0:19:57.94,0:20:00.86,底部中文,,0,0,0,,有很多人都在研究这里的行为
Dialogue: 0,0:20:01.02,0:20:03.54,底部中文,,0,0,0,,如果使用了这些操作码会发生什么呢？
Dialogue: 0,0:20:03.54,0:20:06.02,底部中文,,0,0,0,,如果我们把不存在的0x02操作码插入指令流会怎样？
Dialogue: 0,0:20:06.02,0:20:10.94,底部中文,,0,0,0,,处理器会崩溃吗？还是什么也不做？还是做一些或有用或无用的事？
Dialogue: 0,0:20:11.82,0:20:14.22,底部中文,,0,0,0,,答案是以上情况皆有
Dialogue: 0,0:20:14.62,0:20:18.46,底部中文,,0,0,0,,这取决于你用了哪条非法指令 很多人就此做过研究
Dialogue: 0,0:20:18.82,0:20:20.86,底部中文,,0,0,0,,他们编撰了这张表
Dialogue: 0,0:20:20.86,0:20:26.70,底部中文,,0,0,0,,其中大部分都没什么意义 只是一些指令的组合效果
Dialogue: 0,0:20:26.70,0:20:27.74,底部中文,,0,0,0,,当然部分是有利用价值的
Dialogue: 0,0:20:28.62,0:20:33.70,底部中文,,0,0,0,,我们遇到另一个问题：在描述观察到的现象以外 有办法知道究竟发生了什么吗？
Dialogue: 0,0:20:33.70,0:20:39.46,底部中文,,0,0,0,,这时候我们就需要“自底向上” 即从晶体管角度来理解CPU内部的行为
Dialogue: 0,0:20:39.46,0:20:40.82,底部中文,,0,0,0,,接下来是第二部分“自底向上”
Dialogue: 0,0:20:42.18,0:20:47.10,底部中文,,0,0,0,,如果想要深入研究CPU内部 可以去看数据手册
Dialogue: 0,0:20:47.10,0:20:52.06,底部中文,,0,0,0,,我们能获取到管脚图和时序图
Dialogue: 0,0:20:52.06,0:20:57.26,底部中文,,0,0,0,,当时的文档还不赖 告诉了我们芯片的某些行为
Dialogue: 0,0:20:57.94,0:21:01.42,底部中文,,0,0,0,,你还能看到原理图 比如这个内部结构框图
Dialogue: 0,0:21:01.82,0:21:05.74,底部中文,,0,0,0,,但这幅图既没用也不正确
Dialogue: 0,0:21:06.54,0:21:13.66,底部中文,,0,0,0,,比如一个很重要的差别就是图上只有一条内部总线 而实际上有两条
Dialogue: 0,0:21:06.54,0:21:13.66,顶部注释,,0,0,0,,注：或许是因为内部总线的具体实现对于编程无关紧要，所以芯片设计者刻意隐藏了这些细节
Dialogue: 0,0:21:14.42,0:21:16.82,底部中文,,0,0,0,,我们还能找到一些时序表
Dialogue: 0,0:21:16.82,0:21:21.14,底部中文,,0,0,0,,比如这个就写了采用绝对变址寻址的指令在每隔机器周期进行哪些动作
Dialogue: 0,0:21:21.86,0:21:26.66,底部中文,,0,0,0,,是有点用 但是仍然没有提供关于那些非法指令的有价值的信息
Dialogue: 0,0:21:26.66,0:21:29.50,底部中文,,0,0,0,,我们能做什么？去哪里获取额外的信息？
Dialogue: 0,0:21:29.50,0:21:35.10,底部中文,,0,0,0,,我们只是从上层往下研究 去问那些设计者和公司吗？
Dialogue: 0,0:21:35.10,0:21:37.58,底部中文,,0,0,0,,“你们有没有一些更全面的资料？”
Dialogue: 0,0:21:37.65,0:21:46.06,底部中文,,0,0,0,,实际上这样并不可行 MOS公司在1976年被Commodore公司收购了 而后者早已不存在
Dialogue: 0,0:21:46.06,0:21:50.94,底部中文,,0,0,0,,有趣的是Commodore直到1990年左右才撤出芯片市场
Dialogue: 0,0:21:50.94,0:21:54.74,底部中文,,0,0,0,,最后把这块业务让给了Commodore半导体集团（CSG）
Dialogue: 0,0:21:54.90,0:21:58.74,底部中文,,0,0,0,,所以你会发现MOS留下来的大多数芯片仍然会被冠以“MOS”
Dialogue: 0,0:21:59.38,0:22:02.30,底部中文,,0,0,0,,但是Commodore公司在1994年破产了
Dialogue: 0,0:22:03.30,0:22:07.50,底部中文,,0,0,0,,后来则被ESCOM收购 而GMT微电子拥有了他们的一些晶圆厂
Dialogue: 0,0:22:07.50,0:22:11.86,底部中文,,0,0,0,,ESCOM这家德国零售商也在1995年破产
Dialogue: 0,0:22:12.78,0:22:17.98,底部中文,,0,0,0,,VisCorp买走了一些东西 Gateway买走了Amiga和其他Commodore计算机的知识产权
Dialogue: 0,0:22:17.98,0:22:23.82,底部中文,,0,0,0,,comtech买走了其他所有的零售业务
Dialogue: 0,0:22:23.82,0:22:26.50,底部中文,,0,0,0,,Gateway分出去一个子公司 又给自己改了个名字
Dialogue: 0,0:22:26.70,0:22:32.30,底部中文,,0,0,0,,Commodore的技术还在某处 有人在开发Amiga OS 源码都还在
Dialogue: 0,0:22:32.30,0:22:36.54,底部中文,,0,0,0,,但是我们去问谁呢？我们不知道应该联系何人索取更多信息
Dialogue: 0,0:22:36.54,0:22:38.58,底部中文,,0,0,0,,或许可以联系上这群最初的设计者
Dialogue: 0,0:22:39.26,0:22:51.22,底部中文,,0,0,0,,问他们“你们有相关的DVD/软盘/纸带/穿孔卡片吗？”
Dialogue: 0,0:22:51.22,0:22:57.54,底部中文,,0,0,0,,事实上他们什么都没有 6502及同时代的CPU都是完全手工设计的
Dialogue: 0,0:22:57.54,0:22:58.78,底部中文,,0,0,0,,计算机没有参与设计过程
Dialogue: 0,0:22:59.02,0:23:01.58,底部中文,,0,0,0,,图上有两名芯片版图工程师
Dialogue: 0,0:23:01.98,0:23:05.38,底部中文,,0,0,0,,他们在切割（刻划）Rubylith光掩模（一种红色塑料纸）
Dialogue: 0,0:23:05.78,0:23:11.94,底部中文,,0,0,0,,刻好的掩模会在之后缩放到1平方毫米大小
Dialogue: 0,0:23:12.18,0:23:15.46,底部中文,,0,0,0,,用来光刻制造这些处理器
Dialogue: 0,0:23:16.30,0:23:21.38,底部中文,,0,0,0,,或许人们没有保留这些大图纸的拷贝件
Dialogue: 0,0:23:22.22,0:23:25.66,底部中文,,0,0,0,,但一些相关的文档应该还在
Dialogue: 0,0:23:25.66,0:23:27.82,底部中文,,0,0,0,,在1995年的时候流出了一些资料
Dialogue: 0,0:23:27.82,0:23:32.94,底部中文,,0,0,0,,某人写了一篇相关的论文
Dialogue: 0,0:23:32.94,0:23:39.98,底部中文,,0,0,0,,里面有一幅精美的图表 是6502最初的某个完整原理图
Dialogue: 0,0:23:39.98,0:23:46.46,底部中文,,0,0,0,,作者并没有说明出处 要么是很棒的逆向工程所得 要么就是正宗原版
Dialogue: 0,0:23:46.46,0:23:51.54,底部中文,,0,0,0,,简单看一下 发现程序计数器的逻辑很全很详尽
Dialogue: 0,0:23:51.54,0:23:59.34,底部中文,,0,0,0,,从中可以获取很多信息 只看这幅图有些问题还想不明白 图纸也不是完全无误的
Dialogue: 0,0:23:59.34,0:24:04.66,底部中文,,0,0,0,,但很可能是某个内行画出来的
Dialogue: 0,0:24:04.66,0:24:09.34,底部中文,,0,0,0,,这里是机器周期计数 操作码被保存在左边的指令寄存器中
Dialogue: 0,0:24:09.34,0:24:11.90,底部中文,,0,0,0,,它直接连接着译码ROM
Dialogue: 0,0:24:09.34,0:24:11.90,顶部注释,,0,0,0,,注：译码ROM是芯片内部的掩模只读存储器，存放有微码
Dialogue: 0,0:24:12.58,0:24:14.74,底部中文,,0,0,0,,这些都是寄存器
Dialogue: 0,0:24:15.86,0:24:21.42,底部中文,,0,0,0,,还有两条总线 D总线和S总线 它们将不同的寄存器连接至算术逻辑单元（ALU）
Dialogue: 0,0:24:21.42,0:24:22.66,底部中文,,0,0,0,,这就是算术逻辑单元（ALU）
Dialogue: 0,0:24:23.22,0:24:31.46,底部中文,,0,0,0,,近期又有几页疑似6502完整原理图的图纸流出
Dialogue: 0,0:24:31.46,0:24:37.82,底部中文,,0,0,0,,但似乎不是原版图纸 上面写着“雅达利 1985年”……我看上去像是1984年
Dialogue: 0,0:24:37.98,0:24:42.42,底部中文,,0,0,0,,可能是重制过的 或者是手抄拷贝件
Dialogue: 0,0:24:42.42,0:24:47.14,底部中文,,0,0,0,,上面丢失了很多原本的含义和有趣的注释
Dialogue: 0,0:24:47.30,0:24:52.26,底部中文,,0,0,0,,这是另一个 有几页不完整的图纸 上面写着“ROCKWELL 1982年”
Dialogue: 0,0:24:52.26,0:24:59.06,底部中文,,0,0,0,,这个是手写的 看上去更像是原版 因为上面有许多勘误 对我们更有用
Dialogue: 0,0:24:59.06,0:25:03.58,底部中文,,0,0,0,,它是不完整的 那我们查阅什么来保证逆向工程的正确性呢？
Dialogue: 0,0:25:03.58,0:25:06.98,底部中文,,0,0,0,,你不可能去偷源码 也没办法从某个人手里拿到它
Dialogue: 0,0:25:06.98,0:25:08.74,底部中文,,0,0,0,,只能参考实物不是吗？
Dialogue: 0,0:25:09.02,0:25:13.02,底部中文,,0,0,0,,人们尝试给裸片拍照 这个拍摄的时间比较早
Dialogue: 0,0:25:13.02,0:25:17.50,底部中文,,0,0,0,,人们通过它只能了解到其内部由译码电路、逻辑电路和寄存器组成
Dialogue: 0,0:25:13.02,0:25:17.50,顶部注释,,0,0,0,,注：部分资料中将图上“译码电路”标注为为PLA（可编程逻辑阵列），这是从实现方式上命名的
Dialogue: 0,0:25:17.50,0:25:19.86,底部中文,,0,0,0,,这就是我们从这张照片里得到的所有信息
Dialogue: 0,0:25:20.54,0:25:30.46,底部中文,,0,0,0,,一个名叫Balazs的匈牙利哥们在2001年给6502裸片拍了一些很棒的高分辨率照片
Dialogue: 0,0:25:30.46,0:25:32.46,底部中文,,0,0,0,,他用的是一台老旧的苏联产显微镜
Dialogue: 0,0:25:33.10,0:25:39.90,底部中文,,0,0,0,,虽然是黑白照片但效果很好 他还做了大量工作来重建每一个晶体管
Dialogue: 0,0:25:40.22,0:25:45.02,底部中文,,0,0,0,,之后又绘制了这幅原理图 完整而具体到 每 一 个 晶体管
Dialogue: 0,0:25:52.54,0:26:02.02,底部中文,,0,0,0,,他如饥似渴地一人完成了这所有工作 还用匈牙利语写了一篇论文
Dialogue: 0,0:26:04.22,0:26:05.66,底部中文,,0,0,0,,这……
Dialogue: 0,0:26:06.78,0:26:13.86,底部中文,,0,0,0,,有人将他论文的一部分翻译并试图理解
Dialogue: 0,0:26:13.86,0:26:21.38,底部中文,,0,0,0,,因为他在复制这些门电路的同时对6502处理器的行为建立了深刻的认识
Dialogue: 0,0:26:22.10,0:26:26.74,底部中文,,0,0,0,,还有另一群人 Greg、Barr、 Brian和Ed
Dialogue: 0,0:26:27.22,0:26:32.78,底部中文,,0,0,0,,从去年开始 他们花了大约一年半的时间把这些事情又做了一遍
Dialogue: 0,0:26:32.78,0:26:38.22,底部中文,,0,0,0,,他们的工作正确而高质量 通过调试除错确保没有错误
Dialogue: 0,0:26:38.22,0:26:42.78,底部中文,,0,0,0,,你之前可能也了解过这群来自Visual6502项目的朋友
Dialogue: 0,0:26:43.70,0:26:48.98,底部中文,,0,0,0,,我来向大家讲述部分细节 本来应该是原班人马来这里展示这一部分的
Dialogue: 0,0:26:43.70,0:26:48.98,顶部注释,,0,0,0,,注：该团队在SIGGRAPH 2010上作了汇报
Dialogue: 0,0:26:48.98,0:26:51.78,底部中文,,0,0,0,,所以我只能谈谈我对他们所做工作的理解了
Dialogue: 0,0:26:52.50,0:26:59.98,底部中文,,0,0,0,,这里所做的操作是在芯片上喷热硫酸以溶解塑料封装 这对我来说太危险
Dialogue: 0,0:26:59.98,0:27:01.94,底部中文,,0,0,0,,这样操作以后真正的芯片（裸片）就暴露出来了
Dialogue: 0,0:27:02.14,0:27:04.54,底部中文,,0,0,0,,有时候结果没有那么漂亮……
Dialogue: 0,0:27:04.70,0:27:07.70,底部中文,,0,0,0,,但如果清理干净的话也确实奏效
Dialogue: 0,0:27:07.70,0:27:10.86,底部中文,,0,0,0,,如果操作比较完美 看上去是这样的
Dialogue: 0,0:27:11.14,0:27:12.94,底部中文,,0,0,0,,给大家放大点看一看
Dialogue: 0,0:27:13.50,0:27:16.78,底部中文,,0,0,0,,在这种状态下 芯片大概还是能用的
Dialogue: 0,0:27:17.26,0:27:21.34,底部中文,,0,0,0,,在普通数码相机镜头下 图像分辨率是这样的
Dialogue: 0,0:27:21.86,0:27:24.22,底部中文,,0,0,0,,同样能观察到三个部分
Dialogue: 0,0:27:24.22,0:27:29.18,底部中文,,0,0,0,,顺带一提 译码电路永远在上方 这是6502芯片的正确（参考）方向
Dialogue: 0,0:27:29.34,0:27:32.34,底部中文,,0,0,0,,如果仔细看的话 沃兹尼亚克就站在那旁边
Dialogue: 0,0:27:34.42,0:27:37.14,底部中文,,0,0,0,,下一步就需要获取高分辨率图像了
Dialogue: 0,0:27:37.30,0:27:40.46,底部中文,,0,0,0,,此时就需要一些专业些的设备 比如很好的显微镜
Dialogue: 0,0:27:40.86,0:27:46.50,底部中文,,0,0,0,,Greg的做法是拍很多张很细节的照片 再把它们拼接起来
Dialogue: 0,0:27:46.50,0:27:50.14,底部中文,,0,0,0,,这是其中的一幅照片 看上去挺不错
Dialogue: 0,0:27:51.26,0:27:57.22,底部中文,,0,0,0,,当然只拍摄表面的照片是不够的 这样并不能显示出芯片每一层的内容
Dialogue: 0,0:27:57.22,0:28:00.18,底部中文,,0,0,0,,在图片里你能看到层数标记：3、4、5、6、7
Dialogue: 0,0:28:00.18,0:28:05.78,底部中文,,0,0,0,,你只能从上面俯瞰 但没办法将每一层完美区分开来
Dialogue: 0,0:28:05.78,0:28:10.90,底部中文,,0,0,0,,接下来要用额外的化学试剂将所有上层线路去除 并得到一张这样的照片
Dialogue: 0,0:28:11.34,0:28:18.98,底部中文,,0,0,0,,这样做会毁掉CPU 但我们的目的是为了更好地重建它
Dialogue: 0,0:28:19.70,0:28:25.94,底部中文,,0,0,0,,在完成图像拼接后 他获得了一张有大约两亿像素的图片
Dialogue: 0,0:28:26.14,0:28:29.86,底部中文,,0,0,0,,尺寸是6000x6000像素 足以重建一切细节了
Dialogue: 0,0:28:30.74,0:28:35.18,底部中文,,0,0,0,,他还写了一些绘制多边形用的工具
Dialogue: 0,0:28:35.18,0:28:39.46,底部中文,,0,0,0,,就是他拍摄照片中代表线路的多边形
Dialogue: 0,0:28:40.38,0:28:43.50,底部中文,,0,0,0,,这是第一幅图 这是第二幅图
Dialogue: 0,0:28:43.66,0:28:49.26,底部中文,,0,0,0,,利用这些工具他绘制了层间过孔和走线
Dialogue: 0,0:28:49.26,0:28:52.50,底部中文,,0,0,0,,最后得到了芯片上所有的走线
Dialogue: 0,0:28:52.50,0:28:57.50,底部中文,,0,0,0,,这就是一个完整的、经过重绘的6502 完全用矢量图表示
Dialogue: 0,0:28:57.86,0:28:59.14,底部中文,,0,0,0,,不过还需要除错
Dialogue: 0,0:28:59.14,0:29:08.54,底部中文,,0,0,0,,在一些工具和大量人力的帮助下 这幅照片就变成了最终数字化的着色清晰的成果展示
Dialogue: 0,0:29:10.06,0:29:17.58,底部中文,,0,0,0,,仔细观察走线的相交结点 弄清楚它们在那一层
Dialogue: 0,0:29:17.78,0:29:21.62,底部中文,,0,0,0,,理解NMOS的工作原理和处理过程
Dialogue: 0,0:29:17.78,0:29:21.62,顶部注释,,0,0,0,,注：NMOS即N型金属氧化物半导体，6502是使用NMOS制造（初代6502没有使用CMOS）
Dialogue: 0,0:29:22.18,0:29:24.46,底部中文,,0,0,0,,从中可以获得一张网表
Dialogue: 0,0:29:22.18,0:29:24.46,顶部注释,,0,0,0,,注：网表用于描述电路元件相互连接关系，一般是一个遵循比较简单的标记语法的文本文件
Dialogue: 0,0:29:24.46,0:29:29.70,底部中文,,0,0,0,,网表描述了所有的晶体管以及晶体管之间如何连接、结点和晶体管如何连接
Dialogue: 0,0:29:29.94,0:29:33.46,底部中文,,0,0,0,,一张网表就能详述整个CPU的工作
Dialogue: 0,0:29:33.78,0:29:40.86,底部中文,,0,0,0,,接下来转换网表 这是第一部分网表 这是第二部分 最后是上拉三极管
Dialogue: 0,0:29:41.02,0:29:44.74,底部中文,,0,0,0,,这所有的东西加起来是一个7KB的无序文件
Dialogue: 0,0:29:44.90,0:29:47.86,底部中文,,0,0,0,,也是用来描述6502处理器的所有信息
Dialogue: 0,0:29:47.86,0:29:55.98,底部中文,,0,0,0,,目前最好的办法就是模拟它并且观察现象 而不是试图理解原理图之类的东西
Dialogue: 0,0:29:57.02,0:30:01.18,底部中文,,0,0,0,,如何去模拟这一切呢？简单说就是模拟电路物理状态
Dialogue: 0,0:30:01.46,0:30:07.78,底部中文,,0,0,0,,如果你在外部 就可以控制那些管脚 比如说改变时钟信号的电平
Dialogue: 0,0:30:07.78,0:30:14.26,底部中文,,0,0,0,,然后需要观察和这些管脚直接相连的结点 一直追踪到晶体管
Dialogue: 0,0:30:14.58,0:30:23.26,底部中文,,0,0,0,,检查这些结点的电势 相连处的电势应该是相同的
Dialogue: 0,0:30:23.26,0:30:27.30,底部中文,,0,0,0,,通过测量一组结点的电势得到它们的值
Dialogue: 0,0:30:27.30,0:30:33.58,底部中文,,0,0,0,,将这些结点的电势设置为新值代表的电势后 寻找与这些结点相连的晶体管
Dialogue: 0,0:30:33.58,0:30:36.06,底部中文,,0,0,0,,并根据实际情况翻转一些晶体管的状态
Dialogue: 0,0:30:36.06,0:30:39.94,底部中文,,0,0,0,,之后寻找这些晶体管背后的所有结点 重复上述工作
Dialogue: 0,0:30:39.94,0:30:43.18,底部中文,,0,0,0,,做以上工作足够长时间后 整个系统会稳定下来
Dialogue: 0,0:30:43.18,0:30:46.34,底部中文,,0,0,0,,每个结点的电势也固定了
Dialogue: 0,0:30:46.34,0:30:51.54,底部中文,,0,0,0,,之后可以进入下个阶段（Stage） 改变时钟电平 进入下一个机器周期等等……
Dialogue: 0,0:30:52.78,0:30:56.90,底部中文,,0,0,0,,这么做是会很慢 但它有一些不错的特性
Dialogue: 0,0:30:57.74,0:31:05.54,底部中文,,0,0,0,,通常你第一次写模拟器 这个模拟器通常不会忠于原本的代码 只是个重新实现的复制品
Dialogue: 0,0:30:57.74,0:31:05.54,顶部注释,,0,0,0,,注：一般的软件模拟器只会模拟编程模型（黑箱的行为），而不会在乎具体的硬件实现
Dialogue: 0,0:31:05.98,0:31:15.66,底部中文,,0,0,0,,如果将模拟器精细化下去 数据量不会增加多少 但代码行数和复杂度都会激增
Dialogue: 0,0:31:15.98,0:31:20.66,底部中文,,0,0,0,,如果使用这种网表方法编写模拟器 由于它模拟的是物理状态（及其变化）
Dialogue: 0,0:31:20.86,0:31:27.46,底部中文,,0,0,0,,（随着精细化）代码量不怎么变化 只有几百行 只需要增加数据（多边形）就可以了
Dialogue: 0,0:31:27.66,0:31:33.50,底部中文,,0,0,0,,使用这种方法可以模拟6502 也可以模拟其他处理器 甚至模拟的对象可以不是处理器
Dialogue: 0,0:31:34.54,0:31:40.06,底部中文,,0,0,0,,我讲得已经很慢了 但如果你想让代码跑得更慢 用JavaScript写模拟器就好
Dialogue: 0,0:31:34.54,0:31:40.06,顶部注释,,0,0,0,,JavaScript：这绝对是我被黑得最惨的一次Orz
Dialogue: 0,0:31:47.46,0:31:51.06,底部中文,,0,0,0,,这是一件很棒的HTML5作品
Dialogue: 0,0:31:51.06,0:31:55.54,底部中文,,0,0,0,,这个Viusal6502模拟器是那群伙计制作的 我并没有参与其中
Dialogue: 0,0:31:56.30,0:32:03.50,底部中文,,0,0,0,,那些闪闪烁烁的表明时钟信号在变化 不同的线路在改变电势
Dialogue: 0,0:32:03.86,0:32:08.70,底部中文,,0,0,0,,在右边可以看到时钟信号如何变化 时钟频率大概只有2-3Hz
Dialogue: 0,0:32:08.86,0:32:10.78,底部中文,,0,0,0,,这就是模拟的最快速度
Dialogue: 0,0:32:11.54,0:32:14.30,底部中文,,0,0,0,,所以模拟要比实体芯片慢上一百万倍
Dialogue: 0,0:32:14.58,0:32:17.10,底部中文,,0,0,0,,但可以放大去查看这些细节
Dialogue: 0,0:32:17.30,0:32:21.54,底部中文,,0,0,0,,甚至模拟器还有一个高级模式 我现在把图像关掉
Dialogue: 0,0:32:21.70,0:32:28.78,底部中文,,0,0,0,,运行的时候可以看到很多内部线路的变化 各个组件都在输出什么
Dialogue: 0,0:32:28.78,0:32:32.22,底部中文,,0,0,0,,这对理解一些有趣的边界情况的内部机理很有帮助
Dialogue: 0,0:32:33.10,0:32:35.30,底部中文,,0,0,0,,就模拟而言
Dialogue: 0,0:32:35.30,0:32:40.22,底部中文,,0,0,0,,它太慢了 或许用C语言重新写一个会快一些
Dialogue: 0,0:32:40.58,0:32:45.70,底部中文,,0,0,0,,我参与了这个项目 写了一个C语言模拟器
Dialogue: 0,0:32:47.78,0:32:54.90,底部中文,,0,0,0,,它看上去是这样的 在这个演示里我运行C语言版本的模拟器
Dialogue: 0,0:32:54.90,0:32:58.30,底部中文,,0,0,0,,给它装载好为Commodore 64设计的微软BASIC解释器程序
Dialogue: 0,0:32:58.70,0:33:05.26,底部中文,,0,0,0,,稍等一下……现在它正在统计拥有的内存字节数
Dialogue: 0,0:33:05.82,0:33:06.66,底部中文,,0,0,0,,啊  有这么多内存
Dialogue: 0,0:33:06.66,0:33:11.54,底部中文,,0,0,0,,好的 结束了 用时7秒 这在实体芯片上一般会用几毫秒
Dialogue: 0,0:33:11.54,0:33:13.26,底部中文,,0,0,0,,仍然要慢一千倍
Dialogue: 0,0:33:13.58,0:33:17.22,底部中文,,0,0,0,,我们并不会止步于此 我们要想尽办法让它变得更快
Dialogue: 0,0:33:17.94,0:33:20.26,底部中文,,0,0,0,,这些工具都能帮助我们理解
Dialogue: 0,0:33:20.26,0:33:28.54,底部中文,,0,0,0,,我们可以让一些东西自动化 比如检测所有操作码 看它们修改了哪些寄存器
Dialogue: 0,0:33:28.54,0:33:32.46,底部中文,,0,0,0,,有哪些输入/输出 用时多久等等
Dialogue: 0,0:33:32.46,0:33:38.22,底部中文,,0,0,0,,我们可以在脱离实体硬件的情况下完全自动地获取这些信息 因为我们有完美模拟的硬件
Dialogue: 0,0:33:38.94,0:33:43.38,底部中文,,0,0,0,,我们还可以做一些有趣的测试 比如破坏某些晶体管 看代码能否运行
Dialogue: 0,0:33:43.38,0:33:50.02,底部中文,,0,0,0,,我们可以破坏很多晶体管 代码将部分失效 代码执行并没有用到所有晶体管
Dialogue: 0,0:33:50.90,0:33:55.22,底部中文,,0,0,0,,它另外一个用途就是用作仿真 可惜速度太慢了
Dialogue: 0,0:33:55.22,0:33:59.90,底部中文,,0,0,0,,来看看现有模拟器的数量
Dialogue: 0,0:33:59.90,0:34:03.26,底部中文,,0,0,0,,这是一个NES游戏机模拟器合集的列表
Dialogue: 0,0:34:03.86,0:34:11.46,底部中文,,0,0,0,,之前我问过有谁给这些模拟器写过6502内核 在座的应该有四位
Dialogue: 0,0:34:11.46,0:34:17.46,底部中文,,0,0,0,,但在内核中漏洞很难规避 总有一些奇怪的边界情况没有被考虑到和正确处理
Dialogue: 0,0:34:17.46,0:34:22.58,底部中文,,0,0,0,,现在有了这个完美的（基于晶体管仿真的）模拟器 就可以用它对比着测试你的内核了
Dialogue: 0,0:34:23.14,0:34:24.38,底部中文,,0,0,0,,这不是很棒吗？
Dialogue: 0,0:34:24.78,0:34:29.58,底部中文,,0,0,0,,我们从刚才的工作中学到了什么？我们对CPU的内部行为又理解多少呢？
Dialogue: 0,0:34:29.58,0:34:30.94,底部中文,,0,0,0,,接下来是第三部分“由内而外”
Dialogue: 0,0:34:32.22,0:34:36.22,底部中文,,0,0,0,,一切要从这个精美的原理图（数据通路）讲起
Dialogue: 0,0:34:36.22,0:34:38.98,底部中文,,0,0,0,,我们来聊一聊里面的细节
Dialogue: 0,0:34:38.98,0:34:40.58,底部中文,,0,0,0,,程序计数器没什么特别的
Dialogue: 0,0:34:40.58,0:34:44.54,底部中文,,0,0,0,,这是时序译码器 它是6502处理器的“人格”所在
Dialogue: 0,0:34:44.54,0:34:48.82,底部中文,,0,0,0,,其他的就窸窣平常了 这里的算术逻辑单元和其他处理器差不多
Dialogue: 0,0:34:49.70,0:34:51.50,底部中文,,0,0,0,,这些是寄存器
Dialogue: 0,0:34:51.66,0:34:55.14,底部中文,,0,0,0,,还有堆栈指针和状态寄存器
Dialogue: 0,0:34:56.18,0:34:56.86,底部中文,,0,0,0,,还有两条总线
Dialogue: 0,0:34:56.86,0:35:02.82,底部中文,,0,0,0,,左边的S总线更多地与累加器和算术逻辑单元相连
Dialogue: 0,0:35:02.98,0:35:07.34,底部中文,,0,0,0,,S总线更多地和系统的索引寄存器相连
Dialogue: 0,0:35:08.82,0:35:10.94,底部中文,,0,0,0,,先讲一讲指令译码的部分
Dialogue: 0,0:35:10.94,0:35:14.22,底部中文,,0,0,0,,首先是时序发生器
Dialogue: 0,0:35:16.00,0:35:21.38,底部中文,,0,0,0,,这是某个程序运行时的跟踪结果 可以发现里面有很多交叠的地方
Dialogue: 0,0:35:21.38,0:35:24.14,底部中文,,0,0,0,,这条指令还没有执行完 下一条指令就已经进入取指阶段了
Dialogue: 0,0:35:24.14,0:35:28.38,底部中文,,0,0,0,,这一点与Z80这类处理器有很大差别 它们的一切指令都可以被划分为四个机器周期
Dialogue: 0,0:35:28.38,0:35:32.02,底部中文,,0,0,0,,永远是四个周期 （一条指令执行完成后）执行下一条指令 并经过四个周期
Dialogue: 0,0:35:32.42,0:35:36.18,底部中文,,0,0,0,,而6502指令间有很多交叉 这与内存联系紧密 这使得单个周期中代码执行很快
Dialogue: 0,0:35:36.74,0:35:39.38,底部中文,,0,0,0,,在幻灯片上的这个例子中
Dialogue: 0,0:35:39.38,0:35:41.22,底部中文,,0,0,0,,（高亮行蓝色的）JSR指令还没有执行完
Dialogue: 0,0:35:41.22,0:35:45.58,底部中文,,0,0,0,,但处理器进入了（红色的）T0周期 也就是下一条指令（INX）取指的第一阶段
Dialogue: 0,0:35:45.90,0:35:49.26,底部中文,,0,0,0,,这里INX指令开始译码
Dialogue: 0,0:35:49.42,0:35:54.82,底部中文,,0,0,0,,这里INX指令正在执行 但下一条指令DEY已经完成取指了
Dialogue: 0,0:35:56.10,0:35:58.70,底部中文,,0,0,0,,指令间有很多交叠
Dialogue: 0,0:35:58.70,0:36:01.74,底部中文,,0,0,0,,但这儿是个特例
Dialogue: 0,0:36:01.74,0:36:06.62,底部中文,,0,0,0,,因为INC指令在最后一个周期需要进行内存回写操作
Dialogue: 0,0:36:06.62,0:36:08.78,底部中文,,0,0,0,,所以无法同时取得下一条指令
Dialogue: 0,0:36:09.14,0:36:14.18,底部中文,,0,0,0,,内存正在被使用 故没有交叠现象
Dialogue: 0,0:36:14.50,0:36:16.38,底部中文,,0,0,0,,这一切都被十分有效率地完成
Dialogue: 0,0:36:18.30,0:36:19.86,底部中文,,0,0,0,,这就是时序发生器了
Dialogue: 0,0:36:20.18,0:36:21.78,底部中文,,0,0,0,,下一个组件是译码ROM
Dialogue: 0,0:36:22.10,0:36:31.74,底部中文,,0,0,0,,你能在上方清楚地看到这块译码ROM 它是一个巨大的译码器
Dialogue: 0,0:36:22.10,0:36:31.74,顶部注释,,0,0,0,,注：感兴趣可以去看之前提到的匈牙利大神制作的晶体管级原理图，本质就是与门阵列
Dialogue: 0,0:36:31.74,0:36:36.58,底部中文,,0,0,0,,它就是一块ROM 有21根输入线和130根输出线
Dialogue: 0,0:36:37.42,0:36:42.26,底部中文,,0,0,0,,它接受指令寄存器的内容也就是操作码 作为第一路输入
Dialogue: 0,0:36:37.42,0:36:42.26,顶部注释,,0,0,0,,注：译码ROM存放微指令或微码；在CISC下，微码是复杂指令分解而成的一系列相对简单的指令
Dialogue: 0,0:36:43.10,0:36:44.90,底部中文,,0,0,0,,比如说0xA9代表LDA指令
Dialogue: 0,0:36:43.10,0:36:44.90,顶部注释,,0,0,0,,注：准确的说是采用立即数寻址的LDA指令
Dialogue: 0,0:36:45.38,0:36:49.90,底部中文,,0,0,0,,第二路输入是T信号 代表正处于一条指令的第几个周期
Dialogue: 0,0:36:45.38,0:36:49.90,顶部注释,,0,0,0,,注：1951年, 英国剑桥大学教授M.V.Wilkes首先提出了微程序控制的概念
Dialogue: 0,0:36:49.90,0:36:54.14,底部中文,,0,0,0,,取决于操作码和当前执行周期 下面的一些输出线会被触发
Dialogue: 0,0:36:54.14,0:36:56.86,底部中文,,0,0,0,,不见得是某一根线 也可能同时有几根线被触发
Dialogue: 0,0:36:57.86,0:37:00.50,底部中文,,0,0,0,,比如在之前的例子里这四根线会被触发
Dialogue: 0,0:37:01.38,0:37:04.30,底部中文,,0,0,0,,这张图展示了完整的译码ROM的内容
Dialogue: 0,0:37:04.66,0:37:07.94,底部中文,,0,0,0,,我们仔细观察一下表中的前一（几）个
Dialogue: 0,0:37:08.82,0:37:12.66,底部中文,,0,0,0,,译码ROM会对（操作码，周期T）进行比对
Dialogue: 0,0:37:12.98,0:37:16.02,底部中文,,0,0,0,,但它只关心操作码的前六位
Dialogue: 0,0:37:16.02,0:37:25.46,底部中文,,0,0,0,,后两位和G值有关系 所以被忽略  我稍后将G值是什么 先把它当作操作码的一部分就好
Dialogue: 0,0:37:25.78,0:37:28.26,底部中文,,0,0,0,,表中的X代表“不关心”（任意）
Dialogue: 0,0:37:28.26,0:37:33.98,底部中文,,0,0,0,,例如第一个会匹配所有以“100”开头且倒数第三位为“1”的所有操作码
Dialogue: 0,0:37:34.18,0:37:40.46,底部中文,,0,0,0,,拥有相同操作码掩码的指令 无论处于哪个机器周期 都会匹配这个信号
Dialogue: 0,0:37:42.26,0:37:46.14,底部中文,,0,0,0,,接下来是（上表中）G值的计算 这里给出的是G值的计算规则
Dialogue: 0,0:37:46.14,0:37:51.22,底部中文,,0,0,0,,G值舍干什么的呢？ G1、G2和G3是通往译码ROM的三条独立的信号线
Dialogue: 0,0:37:51.74,0:37:54.94,底部中文,,0,0,0,,这是有关的真值表 其实下面的这个表更有用
Dialogue: 0,0:37:54.94,0:37:57.98,底部中文,,0,0,0,,（操作码的最后两位）有四种组合 分别是00、01、10和11
Dialogue: 0,0:37:58.46,0:38:05.46,底部中文,,0,0,0,,分别对应的是G3、G1、G2 而“11”这种情况是未定义的 6502处理器不使用它
Dialogue: 0,0:38:06.38,0:38:12.58,底部中文,,0,0,0,,也可以把G值解释为指令使用到的寄存器
Dialogue: 0,0:38:12.58,0:38:15.86,底部中文,,0,0,0,,因此指令的最后两位指示的是A、X或Y寄存器
Dialogue: 0,0:38:15.86,0:38:18.50,底部中文,,0,0,0,,当然这两位只对一些（寄存器相关）指令有效 其余指令并不会用到
Dialogue: 0,0:38:18.50,0:38:21.46,底部中文,,0,0,0,,它们不在乎G值 因此“G值”一栏标有“X”
Dialogue: 0,0:38:23.14,0:38:24.98,底部中文,,0,0,0,,我们回过头来看这张操作码表
Dialogue: 0,0:38:25.34,0:38:34.46,底部中文,,0,0,0,,第0、4、8、C列基本上都是和Y寄存器相关的指令
Dialogue: 0,0:38:25.34,0:38:34.46,顶部注释,,0,0,0,,注：列号指示操作码低四位，行号指示操作码高四位
Dialogue: 0,0:38:34.46,0:38:38.98,底部中文,,0,0,0,,几乎就是这种规律 其紧挨着的一列是与A寄存器相关的指令
Dialogue: 0,0:38:38.98,0:38:40.54,底部中文,,0,0,0,,再相邻的列是与X寄存器相关的
Dialogue: 0,0:38:41.74,0:38:43.42,底部中文,,0,0,0,,这就是操作码的最后两位在起作用
Dialogue: 0,0:38:44.46,0:38:52.46,底部中文,,0,0,0,,这是关于译码ROM的一个小视频 粉色的线是目前被触发的线 并随着机器周期变化
Dialogue: 0,0:38:44.46,0:38:52.46,顶部注释,,0,0,0,,注：6502处理器的机器周期使用内存读写定义的，等同于时钟周期
Dialogue: 0,0:38:54.10,0:38:59.74,底部中文,,0,0,0,,接下来浏览一下LDA和LDX指令对应的译码ROM输出
Dialogue: 0,0:39:00.86,0:39:03.06,底部中文,,0,0,0,,二者的编码非常相近
Dialogue: 0,0:39:03.82,0:39:06.98,底部中文,,0,0,0,,它们只有G值不一样
Dialogue: 0,0:39:06.98,0:39:14.14,底部中文,,0,0,0,,所以在第一、二、三个机器周期中 译码ROM（PLA）的输出完全一致 处理器行为相同
Dialogue: 0,0:39:14.50,0:39:21.42,底部中文,,0,0,0,,但在第四个机器周期中有差异 其中一个输出与累加器相关的操作 另一个和X寄存器有关
Dialogue: 0,0:39:22.42,0:39:25.14,底部中文,,0,0,0,,这正是差别所在
Dialogue: 0,0:39:25.50,0:39:29.06,底部中文,,0,0,0,,将目光从译码ROM转移到随机控制逻辑上
Dialogue: 0,0:39:29.74,0:39:34.82,底部中文,,0,0,0,,可以说译码ROM是译码过程的“前端” 而随机控制逻辑是“后端”
Dialogue: 0,0:39:34.82,0:39:39.14,底部中文,,0,0,0,,它从“前端”接收130个输入信号
Dialogue: 0,0:39:39.50,0:39:42.86,底部中文,,0,0,0,,而它的输出在这里 我们把图片放大
Dialogue: 0,0:39:42.86,0:39:45.78,底部中文,,0,0,0,,但愿……好的
Dialogue: 0,0:39:46.14,0:39:51.90,底部中文,,0,0,0,,这些控制信号线直通其他部件 比如算术逻辑单元ALU和总线
Dialogue: 0,0:39:52.26,0:39:55.42,底部中文,,0,0,0,,这些都是非常具体详细的控制信号
Dialogue: 0,0:39:55.42,0:40:00.34,底部中文,,0,0,0,,以这两个信号为例：“将S总线连接到X寄存器”和“将X寄存器连接到S总线”
Dialogue: 0,0:39:55.42,0:40:00.34,顶部注释,,0,0,0,,注：三态门用作数据流向控制与隔离
Dialogue: 0,0:40:00.34,0:40:03.98,底部中文,,0,0,0,,这就是S总线和与之相连的X寄存器
Dialogue: 0,0:40:03.98,0:40:11.46,底部中文,,0,0,0,,可以将S总线上的数据载入到X寄存器中 也可以将X寄存器中的内容传送到S总线上
Dialogue: 0,0:40:11.46,0:40:14.06,底部中文,,0,0,0,,这两根控制信号线分别对应两种操作
Dialogue: 0,0:40:15.10,0:40:17.22,底部中文,,0,0,0,,这就是随机控制逻辑 我也不知道其名字的由来
Dialogue: 0,0:40:17.22,0:40:24.14,底部中文,,0,0,0,,或许是因为它看上去“很随机” 我们也没找到便于理解它工作机制的方法
Dialogue: 0,0:40:24.90,0:40:27.26,底部中文,,0,0,0,,我们举例来看看随机控制逻辑的输出是怎样的
Dialogue: 0,0:40:27.42,0:40:29.74,底部中文,,0,0,0,,这是X自增指令INX的输出情况
Dialogue: 0,0:40:29.94,0:40:34.82,底部中文,,0,0,0,,表里面有译码ROM和随机控制逻辑在第一个周期和第二个周期中的输出
Dialogue: 0,0:40:34.82,0:40:38.22,底部中文,,0,0,0,,我们用数据通路来理解它
Dialogue: 0,0:40:39.14,0:40:43.90,底部中文,,0,0,0,,第一个周期里 INX指令需要获取X寄存器中的信息并将其传送到S总线上
Dialogue: 0,0:40:44.54,0:40:47.50,底部中文,,0,0,0,,再将总线上的数据送入算术逻辑单元ALU的A输入端
Dialogue: 0,0:40:48.34,0:40:51.58,底部中文,,0,0,0,,而数字1需要送入ALU的另一端（B端）用作加法
Dialogue: 0,0:40:51.94,0:40:55.58,底部中文,,0,0,0,,具体要做的是通过提供这一信号输入一位0
Dialogue: 0,0:40:51.94,0:40:55.58,顶部注释,,0,0,0,,注：这里的控制信号是NOT(DB)/ADD，即隔离D总线与ALU的B输入寄存器，并提供低电平
Dialogue: 0,0:40:56.22,0:40:57.62,底部中文,,0,0,0,,再（通过I/ADDC控制信号）加上进位1
Dialogue: 0,0:40:56.22,0:40:57.62,顶部注释,,0,0,0,,注：可以看到I/ADDC信号进入了ALU的CARRY IN（进位输入）端
Dialogue: 0,0:40:57.94,0:40:59.90,底部中文,,0,0,0,,然后选中我们要进行的加法运算
Dialogue: 0,0:41:00.58,0:41:05.46,底部中文,,0,0,0,,这样在下个机器周期 计算结果就会进入ALU右侧的加法器保持寄存器中
Dialogue: 0,0:41:00.58,0:41:05.46,顶部注释,,0,0,0,,注：加法器保存寄存器及ALU的A/B输入寄存器都是为了实现指令设计的辅助寄存器，不能直接操作
Dialogue: 0,0:41:07.74,0:41:12.54,底部中文,,0,0,0,,第二个机器周期中 我们需要取得加法器保持寄存器中的内容
Dialogue: 0,0:41:12.54,0:41:15.18,底部中文,,0,0,0,,使用这两根控制线将其传送到S总线上
Dialogue: 0,0:41:12.54,0:41:15.18,顶部注释,,0,0,0,,注：数据低7位的传送和最高位的传送分两根线控制
Dialogue: 0,0:41:15.54,0:41:17.62,底部中文,,0,0,0,,最后我们将它保存进X寄存器中
Dialogue: 0,0:41:17.62,0:41:24.46,底部中文,,0,0,0,,除此之外还有一些在这条指令中没有实际用途的信号线被触发并使ALU被占用
Dialogue: 0,0:41:24.46,0:41:30.02,底部中文,,0,0,0,,这是为了迎合指令的编码形式而产生的副作用 和具体的指令无关
Dialogue: 0,0:41:30.02,0:41:32.46,底部中文,,0,0,0,,所以这对实际进行的操作没有影响
Dialogue: 0,0:41:32.62,0:41:34.94,底部中文,,0,0,0,,但这两个信号线的触发是有用的
Dialogue: 0,0:41:34.94,0:41:41.74,底部中文,,0,0,0,,它们会根据输出结果分别设置零标志和负数标志
Dialogue: 0,0:41:44.26,0:41:46.14,底部中文,,0,0,0,,接下来是关于软中断BRK、一般外部中断IRQ、不可屏蔽中断NMI和复位的
Dialogue: 0,0:41:46.46,0:41:51.70,底部中文,,0,0,0,,这一切是如何在时序器和逻辑电路中被完成的非常有趣
Dialogue: 0,0:41:52.42,0:41:57.54,底部中文,,0,0,0,,这里展示的是地址空间顶端相关的所有中断向量
Dialogue: 0,0:41:57.54,0:41:59.74,底部中文,,0,0,0,,它们的工作方式彼此相仿
Dialogue: 0,0:41:59.74,0:42:05.02,底部中文,,0,0,0,,一般外部中断IRQ会依次将程序计数器和状态寄存器入栈 并跳转到相应中断向量所指
Dialogue: 0,0:42:05.54,0:42:11.82,底部中文,,0,0,0,,而BRK指令（软中断）和IRQ类似 只不过会设置状态寄存器的B位并入栈
Dialogue: 0,0:42:13.30,0:42:15.66,底部中文,,0,0,0,,NMI和IRQ只存在中断向量地址上的差异
Dialogue: 0,0:42:16.14,0:42:19.14,底部中文,,0,0,0,,复位只会跳转到相应中断向量指向的服务程序 但其实这样说不对
Dialogue: 0,0:42:19.14,0:42:23.18,底部中文,,0,0,0,,实际上复位也会完成程序计数器和状态寄存器入栈流程
Dialogue: 0,0:42:23.18,0:42:28.98,底部中文,,0,0,0,,但没人关心 毕竟都复位了嘛 强调这些既没意思又没什么用
Dialogue: 0,0:42:29.74,0:42:34.98,底部中文,,0,0,0,,看一下这张表 复位操作在“压入程序计数器和状态寄存器”这一栏是“否”
Dialogue: 0,0:42:35.14,0:42:39.90,底部中文,,0,0,0,,但实际上也应该为“是” 这些指令都是相当正交的 实际编码并无两样
Dialogue: 0,0:42:40.26,0:42:42.78,底部中文,,0,0,0,,这里再展示一次编码（及执行过程）
Dialogue: 0,0:42:43.42,0:42:47.66,底部中文,,0,0,0,,先取指 再保存程序计数器的高八位、低八位和状态寄存器（到堆栈）
Dialogue: 0,0:42:43.42,0:42:47.66,顶部注释,,0,0,0,,注：内部总线是八位的，而程序计数器PC是十六位的，故将PC在物理上分为PCH和PCL两部分
Dialogue: 0,0:42:47.66,0:42:51.30,底部中文,,0,0,0,,载入中断向量的低八位和高八位（到PC） 最后取出新指令
Dialogue: 0,0:42:52.54,0:42:55.82,底部中文,,0,0,0,,如果是中断过程 这该怎么实现呢？
Dialogue: 0,0:42:55.82,0:43:00.38,底部中文,,0,0,0,,如果是BRK软中断还好说 毕竟是一条指令 按时序由译码ROM完成译码
Dialogue: 0,0:43:00.54,0:43:02.34,底部中文,,0,0,0,,如果是硬件中断呢？
Dialogue: 0,0:43:02.34,0:43:06.98,底部中文,,0,0,0,,设计师用了一个小技巧 在这里设计了一个叫预解码逻辑的部件
Dialogue: 0,0:43:06.98,0:43:10.54,底部中文,,0,0,0,,它的一个输入是外部中断和复位引脚
Dialogue: 0,0:43:12.18,0:43:17.94,底部中文,,0,0,0,,它的工作原理是：一般情况下指令寄存器IR中的操作码来自于内部数据总线
Dialogue: 0,0:43:18.50,0:43:23.58,底部中文,,0,0,0,,但这里同样有个“0”输入 还有一根IRQ/NMI/复位信号线
Dialogue: 0,0:43:18.50,0:43:23.58,顶部注释,,0,0,0,,注：实际上预解码逻辑就是一个多路复用器MUX
Dialogue: 0,0:43:23.58,0:43:31.54,底部中文,,0,0,0,,只要有IRQ、NMI或复位信号 指令寄存器将不会载入实际的指令 而会载入“0”
Dialogue: 0,0:43:31.86,0:43:36.38,底部中文,,0,0,0,,它起到将“0”插入到程序指令流中的作用
Dialogue: 0,0:43:36.54,0:43:39.54,底部中文,,0,0,0,,你可能还记得 操作码“0x00”是一条BRK指令
Dialogue: 0,0:43:40.22,0:43:44.10,底部中文,,0,0,0,,插入一条BRK指令是一个非常优雅简洁的技巧
Dialogue: 0,0:43:44.10,0:43:50.94,底部中文,,0,0,0,,这样就能执行完整的标准中断流程了 只不过之后需要正确处理中断向量和设置B标志
Dialogue: 0,0:43:50.94,0:43:57.26,底部中文,,0,0,0,,获得具体的中断信息（中断类型）是在别处进行的 但BRK依然遵照中断标准流程
Dialogue: 0,0:43:57.74,0:44:01.30,底部中文,,0,0,0,,这就是漏洞的由来了 还记得之前讲过的有关BRK的漏洞吗？
Dialogue: 0,0:44:01.94,0:44:07.10,底部中文,,0,0,0,,当一个软中断BRK和一般外部中断IRQ同时发生的时候 BRK指令会被忽略
Dialogue: 0,0:44:07.10,0:44:13.02,底部中文,,0,0,0,,原因正在此 处理器会插入一个BRK指令用以处理IRQ 同时会将原来的BRK指令丢弃
Dialogue: 0,0:44:07.10,0:44:13.02,顶部注释,,0,0,0,,注：这样解释其实不够准确，在 http://nesdev.com/6502_cpu.txt 中对此问题有详细讨论
Dialogue: 0,0:44:14.78,0:44:20.78,底部中文,,0,0,0,,我们对处理器的研究也能解答这个读-修改-写指令的双重写入问题
Dialogue: 0,0:44:21.18,0:44:23.22,底部中文,,0,0,0,,其实官方手册已经对此有过记载
Dialogue: 0,0:44:23.22,0:44:28.98,底部中文,,0,0,0,,官方手册这里有一个执行“破坏内存数据”操作的机器周期
Dialogue: 0,0:44:23.22,0:44:28.98,顶部注释,,0,0,0,,注：寄存器都是8位的，地址是16位的，故地址的高八位/低八位分别用ADH/ADL辅助寄存器存放
Dialogue: 0,0:44:29.18,0:44:37.86,底部中文,,0,0,0,,这个操作无关紧要 但如果查看译码ROM就能证实这一点
Dialogue: 0,0:44:37.86,0:44:42.22,底部中文,,0,0,0,,我猜这是出于某种优化的考虑 我们无法理解设计者的用意 但可以观察到这个事实
Dialogue: 0,0:44:43.46,0:44:48.18,底部中文,,0,0,0,,最后来讲一下非法操作码 这是在理解6502的过程中最困难的部分
Dialogue: 0,0:44:48.18,0:44:50.54,底部中文,,0,0,0,,但我觉得我们已经取得很多进展了
Dialogue: 0,0:44:51.02,0:44:56.14,底部中文,,0,0,0,,目前人们所做的工作是通过试验得知这些非法指令的行为
Dialogue: 0,0:44:56.34,0:45:01.06,底部中文,,0,0,0,,有一种理论是说非法指令会有合并临近指令的效果
Dialogue: 0,0:45:01.38,0:45:03.46,底部中文,,0,0,0,,我们可以看到很多实例
Dialogue: 0,0:45:03.46,0:45:07.38,底部中文,,0,0,0,,以KIL非法指令为例 大部分KIL指令都是以十六进制的“2”结尾
Dialogue: 0,0:45:07.38,0:45:12.26,底部中文,,0,0,0,,它的作用是将机器挂起 复位仍能使用 但处理器不会相应IRQ和NMI请求
Dialogue: 0,0:45:13.50,0:45:14.94,底部中文,,0,0,0,,究竟发生了什么呢？
Dialogue: 0,0:45:14.94,0:45:18.66,底部中文,,0,0,0,,我们回到原理图中的时序发生器
Dialogue: 0,0:45:18.66,0:45:21.94,底部中文,,0,0,0,,时序发生器有一路来自随机控制逻辑的输入
Dialogue: 0,0:45:21.94,0:45:26.86,底部中文,,0,0,0,,这是因为在某种程度上时序发生器需要得知何时回到T0进行下一轮的取指
Dialogue: 0,0:45:21.94,0:45:26.86,顶部注释,,0,0,0,,注：T0即一个指令周期中的首个机器周期
Dialogue: 0,0:45:27.06,0:45:35.98,底部中文,,0,0,0,,而随机控制电路从译码ROM那里间接得知当前正在执行的指令和所在周期
Dialogue: 0,0:45:35.98,0:45:38.98,底部中文,,0,0,0,,然后便可以（在适当时机）告知时序发生器“该回到T0了”
Dialogue: 0,0:45:38.98,0:45:41.02,底部中文,,0,0,0,,这就是执行KIL指令出现异常的原因所在
Dialogue: 0,0:45:41.74,0:45:48.70,底部中文,,0,0,0,,左侧是当前所在的周期 并（在中间一栏）用与“012345”对应的位串具体表示
Dialogue: 0,0:45:49.38,0:45:53.06,底部中文,,0,0,0,,对于KIL指令 首先处于T1周期 对应“1”那一位被置1
Dialogue: 0,0:45:53.70,0:45:57.26,底部中文,,0,0,0,,在T2周期中 一些随机的操作发生 具体是什么我们不必关心
Dialogue: 0,0:45:57.26,0:46:02.18,底部中文,,0,0,0,,但我们注意到时序器将位串中的1右移了一位
Dialogue: 0,0:46:02.18,0:46:05.74,底部中文,,0,0,0,,并依次对位串右移 来到T3、T4和T5周期
Dialogue: 0,0:46:05.74,0:46:07.66,底部中文,,0,0,0,,这时并没有信号告知时序器“进行下一次取指”（回到T0）
Dialogue: 0,0:46:07.66,0:46:09.10,底部中文,,0,0,0,,时序器会将那一位1移出位串
Dialogue: 0,0:46:09.23,0:46:11.82,底部中文,,0,0,0,,这时处理器失去了状态
Dialogue: 0,0:46:11.98,0:46:17.50,底部中文,,0,0,0,,之后不会再有操作被匹配 下一条指令也取不到 一切都停在原处
Dialogue: 0,0:46:17.50,0:46:20.62,底部中文,,0,0,0,,处理器陷入“自锁”而宕机了
Dialogue: 0,0:46:22.10,0:46:24.78,底部中文,,0,0,0,,当然有些非法指令比KIL要有用一点
Dialogue: 0,0:46:24.78,0:46:29.74,底部中文,,0,0,0,,表格中的非法指令根据实用性被着上或深或浅的颜色
Dialogue: 0,0:46:29.74,0:46:39.34,底部中文,,0,0,0,,表中有很多NOP指令 可以用匹配不到译码ROM的输出线 从而无任何操作来解释
Dialogue: 0,0:46:29.74,0:46:39.34,顶部注释,,0,0,0,,注：NOP即No Operation，无操作指令，多用来浪费机器周期达到精确计时的目的
Dialogue: 0,0:46:39.34,0:46:43.10,底部中文,,0,0,0,,执行它们的用时和其左边或右边一个指令相同
Dialogue: 0,0:46:43.10,0:46:45.14,底部中文,,0,0,0,,因为译码电路不在乎某些信息
Dialogue: 0,0:46:43.10,0:46:45.14,顶部注释,,0,0,0,,注：这是由多级微指令的设计与指令编码共同决定的
Dialogue: 0,0:46:47.02,0:46:52.54,底部中文,,0,0,0,,某些有趣的指令也可以被解释 而且它们实际上是有使用价值的
Dialogue: 0,0:46:52.54,0:46:55.58,底部中文,,0,0,0,,比如SAX和LAX指令
Dialogue: 0,0:46:52.54,0:46:55.58,顶部注释,,0,0,0,,注：SAX=STA+STX；LAX=LDA+LDX
Dialogue: 0,0:46:55.58,0:47:02.90,底部中文,,0,0,0,,在与Y/A/X寄存器相关的指令右侧 总能发现似乎是结合了A寄存器与X寄存器的非法指令
Dialogue: 0,0:47:03.06,0:47:04.74,底部中文,,0,0,0,,它们被用作存储和载入操作
Dialogue: 0,0:47:05.38,0:47:07.42,底部中文,,0,0,0,,具体的原因之前也提到过
Dialogue: 0,0:47:07.42,0:47:12.70,底部中文,,0,0,0,,取决于G1和G2的计算方式 “未定义”这一栏实际上并不是“未定义”
Dialogue: 0,0:47:14.02,0:47:18.70,底部中文,,0,0,0,,“11”这一栏代表同时产生G1和G2信号
Dialogue: 0,0:47:18.86,0:47:22.26,底部中文,,0,0,0,,于是A寄存器和X寄存器同时被选中
Dialogue: 0,0:47:23.90,0:47:28.78,底部中文,,0,0,0,,如果我们一步步对比LDA、LDX和LAX这三条指令
Dialogue: 0,0:47:29.10,0:47:35.58,底部中文,,0,0,0,,可以看出在T1、T2和T3周期中 LDA和LDX指令的操作是相同的
Dialogue: 0,0:47:35.58,0:47:41.54,底部中文,,0,0,0,,而在T4周期中 LDA做了些和累加器相关的操作 LDX与X寄存器相关 而LAX将两者结合
Dialogue: 0,0:47:41.94,0:47:52.18,底部中文,,0,0,0,,这里是保存至寄存器的操作 由于对应控制线都被选中了 数据会同时装载进A和X寄存器
Dialogue: 0,0:47:53.78,0:47:57.30,底部中文,,0,0,0,,还有很多能被解释的非法指令
Dialogue: 0,0:47:57.30,0:48:05.50,底部中文,,0,0,0,,光去跟踪这些就已经花了很多时间了 但仍有很多有待发掘的东西
Dialogue: 0,0:48:05.50,0:48:10.38,底部中文,,0,0,0,,目前很多人都参与了逆向工程
Dialogue: 0,0:48:10.70,0:48:13.70,底部中文,,0,0,0,,大家用邮件列表和内部百科协同工作
Dialogue: 0,0:48:10.70,0:48:13.70,顶部注释,,0,0,0,,注：邮件列表可以理解为去中心化的“一对多发信”工具
Dialogue: 0,0:48:14.10,0:48:24.90,底部中文,,0,0,0,,我们还在更加深入的研究这些东西 比如为什么有些非法指令会不稳定 另一些如何工作
Dialogue: 0,0:48:24.90,0:48:36.66,底部中文,,0,0,0,,现在展示的是记录操作码和最终随机控制逻辑输出信号映射关系的有趣工作
Dialogue: 0,0:48:36.66,0:48:41.98,底部中文,,0,0,0,,这使得查询特定指令在特定周期时的总线行为变得很方便
Dialogue: 0,0:48:42.62,0:48:47.74,底部中文,,0,0,0,,除此之外 我们研究的不仅是6502芯片本身
Dialogue: 0,0:48:47.74,0:48:52.30,底部中文,,0,0,0,,还有不同6502芯片的对比 要走的路还有很长
Dialogue: 0,0:48:52.30,0:48:56.42,底部中文,,0,0,0,,比如说 有人能认出这是什么芯片吗？
Dialogue: 0,0:48:57.86,0:49:01.50,底部中文,,0,0,0,,右下角有个小小的（也不是很小）的6502处理器
Dialogue: 0,0:49:02.74,0:49:05.30,底部中文,,0,0,0,,就是这里 看上去和普通的6502处理器一模一样
Dialogue: 0,0:49:05.86,0:49:07.90,底部中文,,0,0,0,,它是NES游戏机的CPU
Dialogue: 0,0:49:05.86,0:49:07.90,顶部注释,,0,0,0,,注：这块理光生产的RP2A03（NTSC分频）还集成了声音处理器APU，且缺少原版6502的一些指令
Dialogue: 0,0:49:08.66,0:49:14.78,底部中文,,0,0,0,,它内含一块授权的6502处理器 同一芯片上还有部分音视频逻辑电路
Dialogue: 0,0:49:15.74,0:49:19.38,底部中文,,0,0,0,,还有一些其他版本的6502处理器可供研究对比
Dialogue: 0,0:49:19.38,0:49:28.06,底部中文,,0,0,0,,可以去研究下他们有没有修复某些问题
Dialogue: 0,0:49:28.06,0:49:33.82,底部中文,,0,0,0,,上古版本的原版6502处理器有一些待修复的漏洞
Dialogue: 0,0:49:33.82,0:49:37.10,底部中文,,0,0,0,,Rockwell获得授权生产的版本又有一些小的差别
Dialogue: 0,0:49:37.10,0:49:40.18,底部中文,,0,0,0,,而后来Commodore电脑中的版本有所阉割
Dialogue: 0,0:49:40.78,0:49:43.98,底部中文,,0,0,0,,还有廉价版C64和C128电脑中的版本
Dialogue: 0,0:49:43.98,0:49:47.06,底部中文,,0,0,0,,85xx系列芯片相较于之前有有所缩水
Dialogue: 0,0:49:47.06,0:49:48.86,底部中文,,0,0,0,,研究这些也挺有趣的
Dialogue: 0,0:49:48.86,0:49:51.18,底部中文,,0,0,0,,不过为什么止步于此呢？还有很多其他CPU可供研究啊
Dialogue: 0,0:49:51.18,0:49:56.10,底部中文,,0,0,0,,比方说很有代表性的Z80处理器 人们正在研究它并将它矢量化
Dialogue: 0,0:49:56.82,0:50:00.22,底部中文,,0,0,0,,68000处理器（68k，16/32位混合）则更加复杂 有之前提到的处理器的10倍规模
Dialogue: 0,0:50:00.54,0:50:02.98,底部中文,,0,0,0,,但也有人在试图将其矢量化
Dialogue: 0,0:50:00.54,0:50:02.98,顶部注释,,0,0,0,,注：UP主去看了一下，Z80和68k的逆向工程项目似乎都被咕掉了
Dialogue: 0,0:50:02.98,0:50:08.06,底部中文,,0,0,0,,我们已经有了6502处理器了 为何不去探索一整部电脑呢？
Dialogue: 0,0:50:08.06,0:50:11.66,底部中文,,0,0,0,,一起来研究视频控制器、音频控制器和I/O控制器芯片吧
Dialogue: 0,0:50:08.06,0:50:11.66,顶部注释,,0,0,0,,注：VIC-Video Interface Chip;SID-Sound Interface Device;\NCIA-Complex Interface Adapter（也叫PIA-Peripheral Interface Adapter）
Dialogue: 0,0:50:11.86,0:50:16.50,底部中文,,0,0,0,,借此我们可以建立对一整台电脑的完美模拟 并用它测试现有模拟器
Dialogue: 0,0:50:11.86,0:50:16.50,顶部注释,,0,0,0,,注：相较于数字化的CPU，I/O相关芯片大都为数字/模拟混合IC
Dialogue: 0,0:50:16.82,0:50:19.34,底部中文,,0,0,0,,可以通过散布我们的工作的方式来完成这个宏伟的计划
Dialogue: 0,0:50:19.50,0:50:22.10,底部中文,,0,0,0,,毕竟“众人拾柴火焰高”嘛
Dialogue: 0,0:50:22.10,0:50:29.62,底部中文,,0,0,0,,团队成员正着手制作一个编辑器来方便更多人的协作
Dialogue: 0,0:50:29.94,0:50:33.42,底部中文,,0,0,0,,还有一个计划中的项目 只搞清楚芯片本身是不够的
Dialogue: 0,0:50:33.42,0:50:35.42,底部中文,,0,0,0,,还需要对PCB电路板做X光透视
Dialogue: 0,0:50:33.42,0:50:35.42,顶部注释,,0,0,0,,注：其实就是“抄板”，X光透视只是一种手段
Dialogue: 0,0:50:35.42,0:50:40.82,底部中文,,0,0,0,,有了PCB图纸 才能构建整个系统
Dialogue: 0,0:50:41.54,0:50:43.14,底部中文,,0,0,0,,这也是我们的一个研究方向
Dialogue: 0,0:50:44.06,0:50:50.26,底部中文,,0,0,0,,为什么只用软件模拟呢？我们也可以（用VHDL）编写能跑在FPGA上的模拟
Dialogue: 0,0:50:50.26,0:50:55.02,底部中文,,0,0,0,,有人正在忙碌于将逆向工程的6502处理器“还原”到硬件实体上
Dialogue: 0,0:50:57.38,0:50:58.66,底部中文,,0,0,0,,这就是我分享的全部内容
Dialogue: 0,0:50:58.66,0:51:00.10,底部中文,,0,0,0,,如果你想获取更多信息：
Dialogue: 0,0:51:01.42,0:51:10.54,底部中文,,0,0,0,,在visual6502.org网站获取晶片摄影、百科、JavaScirpt模拟器和稍后放出的矢量化工具
Dialogue: 0,0:51:10.54,0:51:13.94,底部中文,,0,0,0,,6502hackers这个网站上有邮件列表 可以联系到一些很棒的朋友
Dialogue: 0,0:51:13.94,0:51:18.70,底部中文,,0,0,0,,它目前被关闭了 你可以申请会员 我们打算重新启用它
Dialogue: 0,0:51:18.70,0:51:20.46,底部中文,,0,0,0,,当然 别忘了还有我的博客
Dialogue: 0,0:51:21.14,0:51:21.66,底部中文,,0,0,0,,感谢聆听！
Dialogue: 0,0:51:21.14,0:51:21.66,顶部注释,,0,0,0,,UP自翻，喜欢请三连鼓励一下吧～
Dialogue: 0,0:51:36.62,0:51:40.18,底部中文,,0,0,0,,感谢Micheal！各位有问题要问吗？
Dialogue: 0,0:51:36.62,0:51:40.18,顶部注释,,0,0,0,,译者水平有限，望大神纠正指导
