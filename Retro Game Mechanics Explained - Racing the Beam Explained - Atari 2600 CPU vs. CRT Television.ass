[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Last Style Storage: Default
Audio File: 原片.mkv
Video File: 原片.mkv
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 420
Active Line: 438
Video Position: 129569

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: 底部中文,文泉驿微米黑,48,&H00FFFFFF,&H000000FF,&H00FF9300,&H00000000,-1,0,0,0,100,100,0,0,1,0.8,0.8,2,10,10,10,1
Style: 版权信息,文泉驿微米黑,40,&H00FFFFFF,&H000000FF,&H000090FF,&H00000000,-1,0,0,0,100,100,0,0,3,1.5,0.8,9,10,10,10,1
Style: 顶部注释,文泉驿微米黑,40,&H00FFFFFF,&H000000FF,&H000090FF,&H00000000,-1,0,0,0,100,100,0,0,1,0.8,0.8,8,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:00.45,0:00:04.25,底部中文,,0,0,0,,雅达利2600的硬件是极其原始的
Dialogue: 0,0:00:00.45,0:00:04.25,顶部注释,,0,0,0,,【译者注：全机仅有的三片集成电路分别是由MOS Technology提供的6507 CPU和6532 RIOT，以及一片定制的TIA】
Dialogue: 0,0:00:00.45,0:00:04.25,顶部注释,,0,0,0,,【RIOT集成了128字节的SRAM、两个双向8位的并行I/O和一个可编程定时器】
Dialogue: 0,0:00:04.25,0:00:06.95,底部中文,,0,0,0,,为该系统制作的任何一款游戏能够正常运行
Dialogue: 0,0:00:04.25,0:00:06.95,顶部注释,,0,0,0,,【雅达利2600的图像控制器被称作“Television Interface Adaptor”即TIA，同时负责简单声音的产生】
Dialogue: 0,0:00:06.95,0:00:10.19,底部中文,,0,0,0,,无论在工程上还是程序设计上都值得称道
Dialogue: 0,0:00:06.95,0:00:10.19,顶部注释,,0,0,0,,【有趣的是，至今在网络上还能找到当年雅达利工程师设计TIA时的5张手绘原理图】\n【电路功能使用逻辑门表达，关键地方标明了单元电路的晶体管设计和集成电路的工艺参数】
Dialogue: 0,0:00:10.19,0:00:17.24,底部中文,,0,0,0,,它被人津津乐道的最主要原因在于这款游戏机几乎没有显存
Dialogue: 0,0:00:10.19,0:00:17.24,顶部注释,,0,0,0,,【由于RAM太贵，整机可用的内存只有128字节，此外能够存储数据的就只有CPU和TIA中的工作寄存器以及卡带ROM】
Dialogue: 0,0:00:17.24,0:00:20.44,底部中文,,0,0,0,,一片处理器既要处理游戏逻辑
Dialogue: 0,0:00:20.44,0:00:24.15,底部中文,,0,0,0,,又要负责协调图像显示在屏幕上的方式
Dialogue: 0,0:00:24.15,0:00:26.59,底部中文,,0,0,0,,这一切还需要被精确计时
Dialogue: 0,0:00:26.59,0:00:30.01,底部中文,,0,0,0,,并与电视机扫描电子束保持同步
Dialogue: 0,0:00:30.01,0:00:36.39,底部中文,,0,0,0,,因此 这种编程来产生图像的方式常常被称作“与电子束赛跑”
Dialogue: 0,0:00:36.39,0:00:39.84,底部中文,,0,0,0,,那么问题来了 在常规的雅达利2600游戏中
Dialogue: 0,0:00:39.84,0:00:43.96,底部中文,,0,0,0,,为了表示一帧场景 需要使用多少个比特？
Dialogue: 0,0:00:43.96,0:00:53.70,底部中文,,0,0,0,,先给大家一点提示 NTSC电视系统的图像分辨率是160x192像素
Dialogue: 0,0:00:53.70,0:00:56.10,底部中文,,0,0,0,,带有最多30条扫描线的过扫描
Dialogue: 0,0:00:56.10,0:01:03.98,底部中文,,0,0,0,,游戏画面中有一片背景 两个玩家精灵 两个“飞弹”精灵和一个“球”精灵
Dialogue: 0,0:01:03.98,0:01:08.37,底部中文,,0,0,0,,所有这些元素的图形位深度都为1位/像素
Dialogue: 0,0:01:08.37,0:01:12.90,底部中文,,0,0,0,,也就是说 你只可以为同一像素点选择两种颜色之一 即显示与不显示
Dialogue: 0,0:01:12.90,0:01:16.36,底部中文,,0,0,0,,你可以把视频暂停下来 亲自算一算
Dialogue: 0,0:01:20.97,0:01:22.90,底部中文,,0,0,0,,所以我们能得到什么结果？
Dialogue: 0,0:01:22.90,0:01:27.45,底部中文,,0,0,0,,背景部分一共需要160x222（=192+30）比特
Dialogue: 0,0:01:27.45,0:01:37.68,底部中文,,0,0,0,,可能还要再加上玩家精灵的8x20x2比特 飞弹精灵的8x2比特 以及球精灵的1比特
Dialogue: 0,0:01:37.68,0:01:42.53,底部中文,,0,0,0,,一共需要35857个比特来表示
Dialogue: 0,0:01:42.53,0:01:45.53,底部中文,,0,0,0,,如果你也是这样想的 那你的猜测明显偏多
Dialogue: 0,0:01:45.53,0:01:47.89,底部中文,,0,0,0,,事实上需要的比特数要远远比这少
Dialogue: 0,0:01:47.89,0:01:50.61,底部中文,,0,0,0,,正确的答案是39个比特
Dialogue: 0,0:01:50.61,0:01:56.44,底部中文,,0,0,0,,你没听错 只需要39个比特 我甚至可以在屏幕上把它们全部展示出来
Dialogue: 0,0:01:56.44,0:02:01.54,底部中文,,0,0,0,,其中背景部分 在雅达利文档中被叫作“球场” 需要20比特
Dialogue: 0,0:02:01.88,0:02:08.14,底部中文,,0,0,0,,每个玩家精灵需要8比特 两个飞弹精灵和一个球精灵各需要1比特
Dialogue: 0,0:02:08.14,0:02:10.30,底部中文,,0,0,0,,这一切究竟是如何成立的？
Dialogue: 0,0:02:10.30,0:02:14.86,底部中文,,0,0,0,,先让我们关注背景部分 稍后再来看精灵部分
Dialogue: 0,0:02:14.86,0:02:22.87,底部中文,,0,0,0,,之前提到过 雅达利游戏机输出图像的完整大小是水平方向160像素 竖直方向192像素
Dialogue: 0,0:02:22.87,0:02:28.02,底部中文,,0,0,0,,但实际上 背景的有效水平分辨率比这要低
Dialogue: 0,0:02:28.02,0:02:31.67,底部中文,,0,0,0,,它只允许每条扫描线上存在40个各不相同的“像素”
Dialogue: 0,0:02:31.67,0:02:34.25,底部中文,,0,0,0,,我们将其称之为“块”
Dialogue: 0,0:02:34.25,0:02:41.42,底部中文,,0,0,0,,具体来说 背景中的每一个块都是由水平紧邻的4个像素组成的小分组
Dialogue: 0,0:02:41.42,0:02:49.01,底部中文,,0,0,0,,40个背景块乘上每块4个像素 我们就得到了水平方向的160个像素
Dialogue: 0,0:02:49.01,0:02:52.87,底部中文,,0,0,0,,如果我们将每条线上块的数目减半 就只有20个块了
Dialogue: 0,0:02:52.87,0:02:55.81,底部中文,,0,0,0,,这正是背景能使用20个比特来表达的原因
Dialogue: 0,0:02:55.81,0:03:02.79,底部中文,,0,0,0,,背景被水平分割为两半 左半边和右半边共享相同的存储空间
Dialogue: 0,0:03:02.79,0:03:06.34,底部中文,,0,0,0,,这两半可以被设置为重复或者镜像的模式
Dialogue: 0,0:03:06.34,0:03:10.25,底部中文,,0,0,0,,大量的游戏利用到了镜像能力
Dialogue: 0,0:03:10.25,0:03:15.04,底部中文,,0,0,0,,如果我们不想背景呈现重复或者镜像的样式 那该怎么办呢？
Dialogue: 0,0:03:15.04,0:03:18.00,底部中文,,0,0,0,,基本的想法是在游戏代码中
Dialogue: 0,0:03:18.10,0:03:21.20,底部中文,,0,0,0,,只有当电视机扫描电子束将要显示左半屏幕的内容时
Dialogue: 0,0:03:21.20,0:03:28.17,底部中文,,0,0,0,,才把用于显示左半的背景位写进存储
Dialogue: 0,0:03:28.17,0:03:34.36,底部中文,,0,0,0,,紧接着在极短的时间内 电子束向右方移动 将左半边屏幕绘制出来
Dialogue: 0,0:03:34.36,0:03:39.09,底部中文,,0,0,0,,在此期间 右半屏的数据需要被写入
Dialogue: 0,0:03:39.09,0:03:45.29,底部中文,,0,0,0,,以这种方式共享相同的存储区域 两种不同的背景样式被绘制出来
Dialogue: 0,0:03:45.29,0:03:48.24,底部中文,,0,0,0,,这就是“与电子束赛跑”这种说法的来源
Dialogue: 0,0:03:48.24,0:03:49.92,底部中文,,0,0,0,,因为这种方法需要你掐准时机
Dialogue: 0,0:03:49.92,0:03:53.16,底部中文,,0,0,0,,通过计时来得知扫描电子束当前的位置
Dialogue: 0,0:03:53.16,0:04:01.16,底部中文,,0,0,0,,如果过早将另一半的数据写入 前一半的图像就会被破坏 因为尚未完成绘制
Dialogue: 0,0:04:01.16,0:04:06.81,底部中文,,0,0,0,,如果写入得太迟 另一半的图像就会被破坏 因为电子束已经开始绘制这一半
Dialogue: 0,0:04:06.81,0:04:13.95,底部中文,,0,0,0,,这是一个十分微妙的过程 需要计算每一段代码执行所花费的准确时间
Dialogue: 0,0:04:13.95,0:04:17.91,底部中文,,0,0,0,,这样写入存储的操作才能在合适的时机进行
Dialogue: 0,0:04:17.91,0:04:22.71,底部中文,,0,0,0,,到目前为止 我描述的过程仅限于绘制单条扫描线
Dialogue: 0,0:04:22.71,0:04:26.64,底部中文,,0,0,0,,由于整个背景仅有20个比特的存储可用
Dialogue: 0,0:04:26.64,0:04:30.52,底部中文,,0,0,0,,不仅同一行的左右两半共享存储
Dialogue: 0,0:04:30.52,0:04:34.00,底部中文,,0,0,0,,所有的扫描线也要共享相同的存储
Dialogue: 0,0:04:34.00,0:04:40.72,底部中文,,0,0,0,,这意味着如果你希望背景图像随着电子束在屏幕上向下移动而不断改变
Dialogue: 0,0:04:40.72,0:04:45.82,底部中文,,0,0,0,,那么给背景的左右两半写入数据的过程在每一条扫描线上都要发生
Dialogue: 0,0:04:45.82,0:04:49.75,底部中文,,0,0,0,,现在我们明白了这一切的基本思想
Dialogue: 0,0:04:49.75,0:04:54.19,底部中文,,0,0,0,,来看看用来表示背景数据的实际寄存器中的值吧
Dialogue: 0,0:04:54.19,0:04:59.69,底部中文,,0,0,0,,20个比特可以被组织成3个字节 且其中有4个比特是没有用到的
Dialogue: 0,0:04:59.69,0:05:05.21,底部中文,,0,0,0,,存储这3个字节的寄存器被称作PF0、PF1和PF2
Dialogue: 0,0:04:59.69,0:05:05.21,顶部注释,,0,0,0,,【"PF"为背景"Playfield"的简写，为背景寄存器】
Dialogue: 0,0:05:05.21,0:05:13.55,底部中文,,0,0,0,,PF0只用到了高4位 而低4位没有使用 PF1和PF2则被完整使用
Dialogue: 0,0:05:13.55,0:05:18.53,底部中文,,0,0,0,,其中的比特按照以下次序被用来绘制背景的一整条扫描线
Dialogue: 0,0:05:18.53,0:05:26.28,底部中文,,0,0,0,,首先 PF0的4个比特被从最低位到最高位使用 因此其中的数据看起来是倒置的
Dialogue: 0,0:05:26.28,0:05:33.56,底部中文,,0,0,0,,接下来 PF1的8个比特被从最高位到最低位使用 看上去是正着的
Dialogue: 0,0:05:33.56,0:05:41.38,底部中文,,0,0,0,,此后 PF2的8个比特被从最低位到最高位使用 再一次是倒置的
Dialogue: 0,0:05:41.38,0:05:48.06,底部中文,,0,0,0,,如果当前背景被设置为重复显示 这20个比特将以同上的方式被再次绘制
Dialogue: 0,0:05:48.06,0:05:56.78,底部中文,,0,0,0,,否则 如果工作在镜像模式下 这20个比特会按高低位倒置的顺序被绘制以填满整条扫描线
Dialogue: 0,0:05:56.78,0:05:59.75,底部中文,,0,0,0,,因此 为了绘制背景中一条标准的扫描线
Dialogue: 0,0:05:59.75,0:06:05.59,底部中文,,0,0,0,,PF0寄存器中的1个字节需要在电子束开始绘制这条扫描线前被设置好
Dialogue: 0,0:06:05.59,0:06:11.86,底部中文,,0,0,0,,PF1中的一个字节需要在这个点前被写入好 其中的比特将被用作绘制接下来的8个块
Dialogue: 0,0:06:11.86,0:06:20.03,底部中文,,0,0,0,,接下来 PF2的字节需要在这个点前被写好 用来绘制紧接着的8个块
Dialogue: 0,0:06:20.03,0:06:23.15,底部中文,,0,0,0,,最后20个块将使用前面的数据来绘制
Dialogue: 0,0:06:23.15,0:06:31.68,底部中文,,0,0,0,,一旦电子束画完了背景的全部40个块 下一条扫描线的前4个块就能够通过PF0设置
Dialogue: 0,0:06:31.68,0:06:35.96,底部中文,,0,0,0,,那么我们该如何使得右半边和左半边完全不同呢？
Dialogue: 0,0:06:35.96,0:06:39.47,底部中文,,0,0,0,,要求既不能是重复的图样 也不能是镜像的图样
Dialogue: 0,0:06:39.47,0:06:44.44,底部中文,,0,0,0,,这时我们需要在一条线上分别写入每个背景寄存器两次
Dialogue: 0,0:06:44.44,0:06:50.40,底部中文,,0,0,0,,第一次同之前一样写入左半边 而第二次写入右半边
Dialogue: 0,0:06:50.40,0:06:52.67,底部中文,,0,0,0,,我们要格外留意的是
Dialogue: 0,0:06:52.67,0:06:58.74,底部中文,,0,0,0,,背景寄存器在它们对应的块正在被绘制的时候不能被修改
Dialogue: 0,0:06:58.74,0:07:05.36,底部中文,,0,0,0,,当寄存器在同一时刻被写入和读取 就会导致乱码被绘制在屏幕上
Dialogue: 0,0:07:05.36,0:07:10.88,底部中文,,0,0,0,,我们像以前一样更新扫描线的左半边 同时可以在不影响左半边的情况下更新右半边
Dialogue: 0,0:07:10.88,0:07:16.10,底部中文,,0,0,0,,PF0寄存器需要在这个时间点后的某个时刻被更新
Dialogue: 0,0:07:16.10,0:07:17.44,底部中文,,0,0,0,,但必须赶在这个点之前完成更新
Dialogue: 0,0:07:17.44,0:07:23.32,底部中文,,0,0,0,,此后PF1寄存器需要当电子束在这两点之间的某处时被更新
Dialogue: 0,0:07:23.32,0:07:26.74,底部中文,,0,0,0,,最后在这个点之后
Dialogue: 0,0:07:26.74,0:07:27.76,底部中文,,0,0,0,,和这个点以前更新PF2
Dialogue: 0,0:07:30.84,0:07:35.75,底部中文,,0,0,0,,在讲接下来的内容之前 对这一切发生得有多快 让我们建立起直观感觉
Dialogue: 0,0:07:35.75,0:07:43.59,底部中文,,0,0,0,,相对于雅达利的CPU执行指令的速度 电视机电子束移动的速度有多快呢？
Dialogue: 0,0:07:43.59,0:07:51.25,底部中文,,0,0,0,,更新背景寄存器的操作是勉强来得及 还是CPU快到能轻而易举地完成呢？
Dialogue: 0,0:07:51.25,0:07:57.66,底部中文,,0,0,0,,我们知道每个背景块都是由4个像素组成的 现在用一些竖条格线来把它们标注出来
Dialogue: 0,0:07:57.66,0:08:00.33,底部中文,,0,0,0,,现在放大一点来看
Dialogue: 0,0:08:00.33,0:08:07.50,底部中文,,0,0,0,,雅达利2600的CPU是一块6507 它工作在大约1.19 MHz的时钟频率
Dialogue: 0,0:08:00.33,0:08:07.50,顶部注释,,0,0,0,,【译者注：6507是低成本的6502处理器，DIP封装由40脚缩减为28脚，地址线由16根减少为13根，并失去了外部中断能力】
Dialogue: 0,0:08:07.50,0:08:12.74,底部中文,,0,0,0,,考虑到游戏机内部电路利用相同基准时钟信号的方法
Dialogue: 0,0:08:12.74,0:08:22.27,底部中文,,0,0,0,,CPU的一个机器周期与电子束在水平方向上绘制3个像素的时间相同
Dialogue: 0,0:08:22.27,0:08:31.09,底部中文,,0,0,0,,包括水平消隐期在内的整条线要花费76个机器周期的时间来扫描
Dialogue: 0,0:08:31.09,0:08:37.27,底部中文,,0,0,0,,CPU的指令视它们的复杂程度消耗不同数量的机器周期来执行
Dialogue: 0,0:08:37.27,0:08:44.68,底部中文,,0,0,0,,举个栗子 从零页内存进行一次简单的读或写操作只需要3个机器周期
Dialogue: 0,0:08:44.68,0:08:51.52,底部中文,,0,0,0,,因此 向每一个位于零页的背景寄存器写入一个字节都要花费3个周期
Dialogue: 0,0:08:51.52,0:09:00.19,底部中文,,0,0,0,,3个机器周期乘每机器周期3个像素 期间绘制了9个像素 相当于2.25个背景块
Dialogue: 0,0:09:00.19,0:09:08.62,底部中文,,0,0,0,,通过寻找对应于不同背景寄存器的背景块间的边界
Dialogue: 0,0:09:08.62,0:09:14.43,底部中文,,0,0,0,,我们可以标记出背景寄存器最迟能够被写入时 扫描电子束所处的准确位置
Dialogue: 0,0:09:14.43,0:09:18.84,底部中文,,0,0,0,,假设每一个背景寄存器都需要在一条扫描线上被写入两次
Dialogue: 0,0:09:14.43,0:09:18.84,顶部注释,,0,0,0,,【译者注：即对应之前所述的背景左右两半非重复且非镜像的复杂情况】
Dialogue: 0,0:09:18.84,0:09:21.64,底部中文,,0,0,0,,我们发现在最迟的情况下 对PF0的首次写入操作
Dialogue: 0,0:09:21.64,0:09:29.64,底部中文,,0,0,0,,需要在当前扫描线水平消隐期开始后第19个周期时开始执行
Dialogue: 0,0:09:30.36,0:09:33.14,底部中文,,0,0,0,,这次写入操作将花费3个周期
Dialogue: 0,0:09:30.36,0:09:33.14,顶部注释,,0,0,0,,【译者注：黄色区间的长度表征执行该条指令所耗费的时间，对应于3个机器周期或9个像素】
Dialogue: 0,0:09:33.14,0:09:39.09,底部中文,,0,0,0,,此后有一个3个周期的空闲期 空闲间隔后就不得不进行PF1的写入了
Dialogue: 0,0:09:39.09,0:09:44.92,底部中文,,0,0,0,,以此类推 我们在后续的每次写入后分别有7个、8个、2个和8个周期的空闲
Dialogue: 0,0:09:44.92,0:09:50.65,底部中文,,0,0,0,,在完成对PF2的第二次写入后 还剩下11个周期 下一次水平消隐期才会开始
Dialogue: 0,0:09:50.65,0:09:57.71,底部中文,,0,0,0,,正如你所看到的 使用一行76个可用周期中的18个来管理背景绘制 消耗了相当多的CPU时间
Dialogue: 0,0:09:57.71,0:10:02.66,底部中文,,0,0,0,,以上只有写操作 事实上写入的数据还需要某些地方被读出
Dialogue: 0,0:10:02.66,0:10:04.91,底部中文,,0,0,0,,这将会耗费更多的周期
Dialogue: 0,0:10:04.91,0:10:11.60,底部中文,,0,0,0,,我们只完成了背景的绘制 玩家、球和飞弹精灵还没有被绘制呢！
Dialogue: 0,0:10:11.60,0:10:16.86,底部中文,,0,0,0,,CPU还要执行负责处理游戏逻辑和其他一些东西的代码
Dialogue: 0,0:10:16.86,0:10:23.22,底部中文,,0,0,0,,这导致了完整且无镜像、无重复的背景设计并不是很常见
Dialogue: 0,0:10:23.22,0:10:31.93,底部中文,,0,0,0,,也解释了为何大多数游戏采用镜像或大致上呈镜像关系的背景
Dialogue: 0,0:10:31.93,0:10:33.70,底部中文,,0,0,0,,下面来看一看精灵吧！
Dialogue: 0,0:10:33.70,0:10:39.24,底部中文,,0,0,0,,画面中可以存在两个玩家精灵、两个飞弹精灵和一个球精灵
Dialogue: 0,0:10:39.24,0:10:43.09,底部中文,,0,0,0,,两个玩家精灵分别使用8个比特来表示它们的图像
Dialogue: 0,0:10:43.09,0:10:47.69,底部中文,,0,0,0,,和背景一样 对于玩家精灵 一次只能存储其一行的图像
Dialogue: 0,0:10:43.09,0:10:47.69,顶部注释,,0,0,0,,【译者注：寄存器名字中的"GR"代表"Graphics"，"P"代表"Player"】
Dialogue: 0,0:10:47.69,0:10:52.39,底部中文,,0,0,0,,因此 如果你的精灵在竖直方向上有形状的变化 就需要在执行过程中不断更新寄存器
Dialogue: 0,0:10:52.39,0:10:58.09,底部中文,,0,0,0,,实际上 禁用玩家精灵的唯一方式就是将其图形位设为全0
Dialogue: 0,0:10:58.09,0:11:00.62,底部中文,,0,0,0,,所以在精灵的最后一行绘制完成后还需要清除对应寄存器
Dialogue: 0,0:11:00.62,0:11:05.75,底部中文,,0,0,0,,否则玩家精灵就会变成跨越整个屏幕的纵向长条
Dialogue: 0,0:11:05.75,0:11:12.67,底部中文,,0,0,0,,两个飞弹精灵和一个球精灵都只用一个比特的像素点来表示 指示精灵的显示与否
Dialogue: 0,0:11:05.75,0:11:12.67,顶部注释,,0,0,0,,【译者注：寄存器名字中的“ENA”代表“Enable”，“M”代表“Missile”，“BL”代表“Ball”，都只有第1位有效】
Dialogue: 0,0:11:12.67,0:11:20.14,底部中文,,0,0,0,,一对寄存器能够控制玩家和飞弹精灵在扫描线上的拉伸和重复
Dialogue: 0,0:11:20.14,0:11:25.27,底部中文,,0,0,0,,但无论拉伸或重复被设置与否 每个玩家的图形仍然用8个比特表示 每个显示的飞弹精灵用1个比特表示
Dialogue: 0,0:11:20.14,0:11:25.27,顶部注释,,0,0,0,,【译者注：“NUSIZE”即为“Number and Size”，是数量与尺寸寄存器】
Dialogue: 0,0:11:25.27,0:11:30.74,底部中文,,0,0,0,,然而 这些控制拉伸和重复的位在绘制图案副本过程中依然是可以被更新的
Dialogue: 0,0:11:30.74,0:11:38.14,底部中文,,0,0,0,,这使得可以在同一条线上使用同样的精灵图像数据绘制出两个看上去不同的精灵
Dialogue: 0,0:11:38.14,0:11:48.18,底部中文,,0,0,0,,假如你有一张8x8像素的小图像 希望使用0号玩家精灵将它显示在屏幕上的特定位置
Dialogue: 0,0:11:48.18,0:11:54.83,底部中文,,0,0,0,,比如说 在距离屏幕顶端40条线 距离屏幕左侧60像素的这个地方
Dialogue: 0,0:11:54.83,0:12:00.91,底部中文,,0,0,0,,只需要将一个字节的值60写入X坐标寄存器 将40写入Y坐标寄存器 不是吗？
Dialogue: 0,0:12:00.91,0:12:02.80,底部中文,,0,0,0,,如果真的是这样就太简单了
Dialogue: 0,0:12:02.80,0:12:05.69,底部中文,,0,0,0,,实际上这两个坐标寄存器都不存在
Dialogue: 0,0:12:05.69,0:12:11.45,底部中文,,0,0,0,,定位精灵的工作需要通过扫描线和机器周期的计数来手动完成
Dialogue: 0,0:12:11.45,0:12:14.60,底部中文,,0,0,0,,先来处理水平坐标分量吧
Dialogue: 0,0:12:14.60,0:12:21.39,底部中文,,0,0,0,,最简单的设定精灵水平坐标的方法是使用精灵复位寄存器
Dialogue: 0,0:12:21.39,0:12:25.28,底部中文,,0,0,0,,每个精灵都有一个复位寄存器 一共有五个
Dialogue: 0,0:12:21.39,0:12:25.28,顶部注释,,0,0,0,,【译者注：“RES”表示“Reset”，“P”是玩家，“M”是飞弹，“BL”是球】
Dialogue: 0,0:12:25.28,0:12:27.05,底部中文,,0,0,0,,当其中某个寄存器被写入
Dialogue: 0,0:12:27.05,0:12:31.54,底部中文,,0,0,0,,由于这些寄存器都是“选通寄存器” 写入的值是无关紧要的
Dialogue: 0,0:12:31.54,0:12:37.20,底部中文,,0,0,0,,此时对应精灵的位置就会被设定为当前扫描电子束的位置
Dialogue: 0,0:12:37.20,0:12:41.69,底部中文,,0,0,0,,同时会存在些许延迟问题 导致精灵的实际位置相对于当前电子束略微靠右
Dialogue: 0,0:12:41.69,0:12:48.14,底部中文,,0,0,0,,对于没有被拉伸的玩家精灵来说 会相对于写指令执行完成的地方右偏5个像素
Dialogue: 0,0:12:48.14,0:12:54.16,底部中文,,0,0,0,,根据以上 为了使我们的精灵显示在距离屏幕左边缘60个像素的地方
Dialogue: 0,0:12:54.16,0:13:02.98,底部中文,,0,0,0,,应该确保CPU在电子束正在绘制当前扫描线的第55个像素时 完成对复位寄存器的写操作
Dialogue: 0,0:13:02.98,0:13:06.50,底部中文,,0,0,0,,我们该如何获得扫描电子束在某一时刻的准确位置呢？
Dialogue: 0,0:13:06.50,0:13:11.17,底部中文,,0,0,0,,但是没有可以用来读取扫描线当前位置的寄存器
Dialogue: 0,0:13:11.17,0:13:15.84,底部中文,,0,0,0,,办法是将CPU与电子束在某一个已知的位置同步
Dialogue: 0,0:13:15.84,0:13:18.77,底部中文,,0,0,0,,接下来通过记录你的代码中用到的每一条指令的机器周期数
Dialogue: 0,0:13:18.77,0:13:22.98,底部中文,,0,0,0,,来自主持续跟踪扫描线行进的距离
Dialogue: 0,0:13:22.98,0:13:31.00,底部中文,,0,0,0,,有一个叫做“WSYNC”的特殊寄存器能够将CPU暂停 直至电子束完成一条扫描线的扫描
Dialogue: 0,0:13:22.98,0:13:31.00,顶部注释,,0,0,0,,【译者注：挂起CPU的操作是通过控制其RDY信号来实现的，这是6507为数不多的没被阉割的功能引脚】
Dialogue: 0,0:13:22.98,0:13:31.00,顶部注释,,0,0,0,,【“WSYNC”即“Wait for Synchronization”，同样是一个TIA中的选通寄存器】
Dialogue: 0,0:13:31.00,0:13:38.60,底部中文,,0,0,0,,这样 在写入WSYNC寄存器后的指令就会在水平消隐期的开始被继续执行
Dialogue: 0,0:13:38.84,0:13:45.53,底部中文,,0,0,0,,也就是下一条线的第一个可见像素前68个等效像素的位置
Dialogue: 0,0:13:45.53,0:13:47.62,底部中文,,0,0,0,,所以我们需要在与水平消隐期的起始同步后
Dialogue: 0,0:13:47.62,0:13:53.30,底部中文,,0,0,0,,等待68个像素的时间 再加上我们需要的55个像素的偏移的时间
Dialogue: 0,0:13:53.30,0:13:56.16,底部中文,,0,0,0,,再写入RESP0寄存器来复位精灵位置
Dialogue: 0,0:14:00.28,0:14:04.17,底部中文,,0,0,0,,68加上55一共有123个像素
Dialogue: 0,0:14:04.17,0:14:06.82,底部中文,,0,0,0,,而每个机器周期绘制3个像素
Dialogue: 0,0:14:06.82,0:14:09.05,底部中文,,0,0,0,,我们计算得到41个机器周期
Dialogue: 0,0:14:09.05,0:14:14.60,底部中文,,0,0,0,,写指令本身花费3个周期 所以还需要再等38个周期
Dialogue: 0,0:14:14.60,0:14:17.64,底部中文,,0,0,0,,我们需要装载精灵的图像数据
Dialogue: 0,0:14:17.64,0:14:22.47,底部中文,,0,0,0,,如果使用立即数寻址的LDA指令来将常数图像加载进累加器 需要5个周期
Dialogue: 0,0:14:22.47,0:14:25.75,底部中文,,0,0,0,,之后还需要STA指令来把累加器数据存入图像寄存器
Dialogue: 0,0:14:25.75,0:14:29.64,底部中文,,0,0,0,,完成了这些 就只剩33个周期的等待了
Dialogue: 0,0:14:29.64,0:14:34.97,底部中文,,0,0,0,,如果此时当前扫描线上没有其它需要做的工作 就可以使用一些NOP指令来等待
Dialogue: 0,0:14:34.97,0:14:39.73,底部中文,,0,0,0,,每条NOP指令什么也不做 仅仅占用2个周期来执行
Dialogue: 0,0:14:39.73,0:14:47.02,底部中文,,0,0,0,,由于找不到仅消耗1个周期的指令 我们需要一条花费3个周期的指令 来正好凑够33个周期
Dialogue: 0,0:14:47.02,0:14:53.41,底部中文,,0,0,0,,STA指令花费3个周期来执行 所以可以把它执行两次
Dialogue: 0,0:14:53.41,0:14:57.17,底部中文,,0,0,0,,综上所述 在显示精灵的第一行 代码将是以下这样
Dialogue: 0,0:14:57.17,0:14:59.82,底部中文,,0,0,0,,一条LDA指令用于准备图像数据
Dialogue: 0,0:14:59.82,0:15:02.14,底部中文,,0,0,0,,一条STA指令用于写入图像
Dialogue: 0,0:15:02.14,0:15:06.10,底部中文,,0,0,0,,另一条没什么作用的STA指令 只是用来凑3个周期
Dialogue: 0,0:15:06.10,0:15:08.57,底部中文,,0,0,0,,15条NOP指令
Dialogue: 0,0:15:08.57,0:15:12.10,底部中文,,0,0,0,,接下来使用一条STA指令来写RESP0寄存器
Dialogue: 0,0:15:12.10,0:15:17.80,底部中文,,0,0,0,,最后使用STA指令来写入WSYNC寄存器 等待下一条扫描线开始
Dialogue: 0,0:15:17.80,0:15:24.44,底部中文,,0,0,0,,每个精灵的水平位置在再次写入对应的位置复位寄存器前都会保持不变
Dialogue: 0,0:15:24.44,0:15:30.36,底部中文,,0,0,0,,为了绘制精灵接下来的7行图像 我们更新该精灵的图像寄存器即可
Dialogue: 0,0:15:30.36,0:15:34.72,底部中文,,0,0,0,,这使得代码更加短小 因为无需做任何指定周期的等待操作
Dialogue: 0,0:15:34.72,0:15:40.70,底部中文,,0,0,0,,只需要加载并存储一个字节的图像 再写入WSYNC寄存器即可
Dialogue: 0,0:15:40.70,0:15:47.78,底部中文,,0,0,0,,以上操作将会把精灵定位在正确的水平位置 但我们还需要关注竖直位置的问题
Dialogue: 0,0:15:47.78,0:15:51.77,底部中文,,0,0,0,,也许你会认为从屏幕顶端开始计数40条扫描线是很容易的事情？
Dialogue: 0,0:15:51.77,0:15:59.59,底部中文,,0,0,0,,然而 和使用WSYNC寄存器来同步水平位置不同 我们没有办法使得CPU和电子束保持垂直同步
Dialogue: 0,0:15:59.59,0:16:05.39,底部中文,,0,0,0,,实际上雅达利游戏机连控制垂直同步和消隐的电路都没有
Dialogue: 0,0:15:59.59,0:16:05.39,顶部注释,,0,0,0,,【译者注：以复合视频信号中的一条扫描线为例：“同步”指发送负脉冲告知电视机新一行的开始】
Dialogue: 0,0:15:59.59,0:16:05.39,顶部注释,,0,0,0,,【“消隐”指在同步后发送一段时间的黑电平来标识黑色，其上承载有彩色突发信号，提供表达彩色信息的基准频率和相位】
Dialogue: 0,0:16:05.39,0:16:09.37,底部中文,,0,0,0,,垂直同步和消隐都需要在游戏代码中完成
Dialogue: 0,0:16:09.37,0:16:15.18,底部中文,,0,0,0,,电视机使用垂直同步脉冲来得知一帧图像的起始与结束
Dialogue: 0,0:16:15.18,0:16:23.93,底部中文,,0,0,0,,垂直同步期非常短 期间会输出一个“比黑色还要黑”的负电压视频信号
Dialogue: 0,0:16:23.93,0:16:29.18,底部中文,,0,0,0,,垂直同步电平可以通过设置一个特殊的“VSYNC”寄存器来使能或除能
Dialogue: 0,0:16:29.18,0:16:36.79,底部中文,,0,0,0,,为了保证输出图像的正确 VSYNC寄存器需要被置位并保持3条扫描线的时间后再复位为0
Dialogue: 0,0:16:36.79,0:16:40.79,底部中文,,0,0,0,,实现以上操作很简单
Dialogue: 0,0:16:40.79,0:16:46.30,底部中文,,0,0,0,,通过WSYNC寄存器 可以确保对VSYNC寄存器的读写操作都恰好发生在水平消隐的起始处
Dialogue: 0,0:16:46.30,0:16:51.61,底部中文,,0,0,0,,在将VSYNC重置为0后 垂直消隐期就开始了
Dialogue: 0,0:16:46.30,0:16:51.61,顶部注释,,0,0,0,,【译者注：在逐行扫描模式下，垂直消隐等同于场消隐】
Dialogue: 0,0:16:51.61,0:16:55.99,底部中文,,0,0,0,,同样有个叫做“VBLANK”的寄存器与垂直消隐有关
Dialogue: 0,0:16:55.99,0:17:02.54,底部中文,,0,0,0,,寄存器中的对应位需要在垂直消隐期开始时被设置为1 并在结束时清零
Dialogue: 0,0:17:02.54,0:17:10.25,底部中文,,0,0,0,,在水平消隐期中 扫描电子束从上一行末端移动到下一行的开始
Dialogue: 0,0:17:10.25,0:17:18.12,底部中文,,0,0,0,,垂直消隐期与之类似 电子束需要从屏幕底部移动到顶部 开始新的一帧
Dialogue: 0,0:17:18.12,0:17:24.62,底部中文,,0,0,0,,NTSC制式的垂直消隐期有37条扫描线 而PAL制式有45条扫描线
Dialogue: 0,0:17:24.63,0:17:28.59,底部中文,,0,0,0,,因此 为了让精灵从第40条可见扫描线开始显示
Dialogue: 0,0:17:28.59,0:17:35.07,底部中文,,0,0,0,,我们需要在垂直同步结束后 再等待40加上37即77条线
Dialogue: 0,0:17:35.07,0:17:40.76,底部中文,,0,0,0,,我们可以用这争取到的额外时间来处理可能的游戏逻辑
Dialogue: 0,0:17:40.76,0:17:49.29,底部中文,,0,0,0,,只有在垂直消隐期 我们不需要考虑更新图像的问题 所以这是处理其他事情的好时机
Dialogue: 0,0:17:49.29,0:17:58.96,底部中文,,0,0,0,,在这个例子中 我们除了显示精灵外无事可做 所以可以写入若干次WSYNC寄存器来完成所需的等待
Dialogue: 0,0:17:58.96,0:18:02.40,底部中文,,0,0,0,,记得在合适的时机清除VBLANK寄存器退出垂直消隐期
Dialogue: 0,0:18:02.40,0:18:10.60,底部中文,,0,0,0,,之后再写入WSYNC寄存器40次（我们想让精灵显示在距离屏幕顶端40条线的位置）
Dialogue: 0,0:18:10.60,0:18:16.10,底部中文,,0,0,0,,最后 我们就可以将前面写的设置精灵图像及水平位置的代码追加在后面了
Dialogue: 0,0:18:19.22,0:18:21.04,底部中文,,0,0,0,,让我们再看几个例子
Dialogue: 0,0:18:21.04,0:18:24.02,底部中文,,0,0,0,,先来看看《E.T.外星人》的标题画面
Dialogue: 0,0:18:21.04,0:18:24.02,顶部注释,,0,0,0,,【译者注：《E.T.外星人》是一款于1982年根据同名电影制作的游戏，是雅达利1983至1984年重大亏损的重要诱因】
Dialogue: 0,0:18:24.02,0:18:30.00,底部中文,,0,0,0,,它由两个元素组成 我们使用它们来展示一个简单的和一个更复杂一些的画面实现方式
Dialogue: 0,0:18:30.00,0:18:32.63,底部中文,,0,0,0,,第一个元素是上面的标题文字“E.T.”
Dialogue: 0,0:18:32.63,0:18:38.72,底部中文,,0,0,0,,字母“E”使用0号玩家精灵来绘制 而字母“T”使用了1号玩家精灵
Dialogue: 0,0:18:38.72,0:18:43.05,底部中文,,0,0,0,,两个句点则分别使用0和1号飞弹精灵绘制
Dialogue: 0,0:18:43.05,0:18:47.13,底部中文,,0,0,0,,下面是在屏幕上定位这些精灵的代码
Dialogue: 0,0:18:47.13,0:18:51.22,底部中文,,0,0,0,,循环体被执行了五次 每次定位一个精灵
Dialogue: 0,0:18:47.13,0:18:51.22,顶部注释,,0,0,0,,【译者注：这段设置精灵水平位置的代码需要在精灵第一行被显示之前的扫描线上执行】
Dialogue: 0,0:18:51.22,0:18:55.08,底部中文,,0,0,0,,球精灵也被放置了 只是在这个例子中不显示
Dialogue: 0,0:18:55.08,0:19:02.97,底部中文,,0,0,0,,在循环的开始有一个对WSYNC寄存器的写操作 这表明每条扫描线上都只会执行一次循环迭代
Dialogue: 0,0:19:02.97,0:19:06.21,底部中文,,0,0,0,,主循环体被分为两个部分
Dialogue: 0,0:19:06.21,0:19:13.85,底部中文,,0,0,0,,首先 某些值被从游戏ROM中读出 并写进（HMP0）这个寄存器中 我们稍后再详细了解
Dialogue: 0,0:19:13.85,0:19:21.82,底部中文,,0,0,0,,接下来在这里 读出字节的低4位被用作短小内循环执行次数的计数
Dialogue: 0,0:19:21.82,0:19:29.25,底部中文,,0,0,0,,内循环的作用仅仅是通过浪费时间 等待扫描电子束到达屏幕上特定的点
Dialogue: 0,0:19:29.25,0:19:33.69,底部中文,,0,0,0,,此后 对相应的位置复位寄存器做写操作
Dialogue: 0,0:19:33.69,0:19:38.07,底部中文,,0,0,0,,最后 对X索引寄存器做自减操作 执行下一次主循环迭代
Dialogue: 0,0:19:33.69,0:19:38.07,顶部注释,,0,0,0,,【译者注：这里的“--”和“-”分别为外循环（主循环）和内循环起始的行标号】
Dialogue: 0,0:19:38.07,0:19:44.72,底部中文,,0,0,0,,在循环结束后 又做了一次行同步操作 并且又写入了另一个我们还没有见过的寄存器（HMOVE）
Dialogue: 0,0:19:44.72,0:19:50.19,底部中文,,0,0,0,,这两个新出现的寄存器（HMP0和HMOVE）分别是水平移动寄存器和应用移动寄存器
Dialogue: 0,0:19:50.19,0:19:54.98,底部中文,,0,0,0,,这是移动精灵的另一种方式
Dialogue: 0,0:19:50.19,0:19:54.98,顶部注释,,0,0,0,,【译者注：第一种方式为写入对应的精灵复位寄存器，设置其水平坐标为当前电子束位置】
Dialogue: 0,0:19:54.98,0:20:02.70,底部中文,,0,0,0,,还记得CPU的一个机器周期等同于电子束扫过3个像素的时间吗？
Dialogue: 0,0:20:02.70,0:20:10.41,底部中文,,0,0,0,,这就意味着 只使用位置复位寄存器的话 水平坐标分辨率就会受到3的倍数的影响
Dialogue: 0,0:20:10.41,0:20:17.63,底部中文,,0,0,0,,为了将精灵水平坐标的粒度细化到一个像素 就要使用到水平移动寄存器
Dialogue: 0,0:20:17.63,0:20:21.19,底部中文,,0,0,0,,向HM系列寄存器的高四位写入数据
Dialogue: 0,0:20:17.63,0:20:21.19,顶部注释,,0,0,0,,【译者注：“HM”代表“Horizontal Movement”，即表示水平移动或水平偏移】
Dialogue: 0,0:20:21.19,0:20:26.80,底部中文,,0,0,0,,可以将写入的值所表示的像素个数作为对应精灵的偏移 并等待生效
Dialogue: 0,0:20:26.80,0:20:32.03,底部中文,,0,0,0,,偏移的范围为向左7个像素到向右8个像素
Dialogue: 0,0:20:26.80,0:20:32.03,顶部注释,,0,0,0,,【即为4位有符号数能够表示的范围】
Dialogue: 0,0:20:32.03,0:20:34.99,底部中文,,0,0,0,,当值被写入后 移动并不会立即生效
Dialogue: 0,0:20:34.99,0:20:43.09,底部中文,,0,0,0,,在对HMOVE寄存器做写操作前 写入的5个精灵的偏移值会一直保持等待生效状态
Dialogue: 0,0:20:43.09,0:20:50.29,底部中文,,0,0,0,,换句话说 你可以把对位置复位寄存器的写入看做对水平坐标的粗略设置
Dialogue: 0,0:20:50.29,0:21:01.28,底部中文,,0,0,0,,而对水平移动寄存器的写入和应用操作 则可以被看做对横坐标的微调
Dialogue: 0,0:21:01.28,0:21:07.19,底部中文,,0,0,0,,举例来说 对字母“E” 从ROM读取到的对应值为0x52
Dialogue: 0,0:21:07.19,0:21:16.79,底部中文,,0,0,0,,这一字节的数据被写进了HMP0寄存器 由于只有高4位有效 相当于向左移动5个像素
Dialogue: 0,0:21:16.79,0:21:23.95,底部中文,,0,0,0,,接下来 低4位数据被用作内循环的计数 即分支（跳转）操作会被执行2次
Dialogue: 0,0:21:23.95,0:21:32.54,底部中文,,0,0,0,,如果我们数一数这段子程序的机器周期数 就会发现每执行一次内循环体就会多用掉5个机器周期
Dialogue: 0,0:21:32.54,0:21:39.88,底部中文,,0,0,0,,意味着每执行一次内循环体 精灵的粗略位置就会向右移动5x3=15个像素
Dialogue: 0,0:21:39.88,0:21:42.62,底部中文,,0,0,0,,而这一范围又恰好能被水平位置的精细调整所覆盖
Dialogue: 0,0:21:42.62,0:21:49.02,底部中文,,0,0,0,,因为精细移动的范围是向左移7个像素至向右移8个像素 一共有16个像素的范围可供调整
Dialogue: 0,0:21:49.02,0:21:57.85,底部中文,,0,0,0,,对于大写字母“E”对应的精灵来说 对RESP0寄存器的写入发生在水平消隐开始以后的第36个机器周期
Dialogue: 0,0:21:57.85,0:22:02.29,底部中文,,0,0,0,,即对应于第36x3=108个像素的位置
Dialogue: 0,0:22:02.29,0:22:05.70,底部中文,,0,0,0,,先减去水平消隐期等效的68个像素
Dialogue: 0,0:22:05.70,0:22:10.79,底部中文,,0,0,0,,再加上在精灵被拉伸情况下6个像素的延迟偏移
Dialogue: 0,0:22:10.79,0:22:15.05,底部中文,,0,0,0,,得知精灵被粗略放置在距离屏幕左边缘46个可见像素处
Dialogue: 0,0:22:15.05,0:22:19.04,底部中文,,0,0,0,,在本次循环结束后 其他的精灵的粗略位置被同上设置
Dialogue: 0,0:22:19.04,0:22:21.39,底部中文,,0,0,0,,同时用于微调的HM系列寄存器也都被设置好
Dialogue: 0,0:22:21.39,0:22:24.14,底部中文,,0,0,0,,一切就绪后 HMOVE寄存器被写入
Dialogue: 0,0:22:24.14,0:22:31.02,底部中文,,0,0,0,,对HMOVE寄存器的写操作 将会导致按照HM系列寄存器中存储的值 分别对所有精灵做若干像素的偏移
Dialogue: 0,0:22:31.02,0:22:37.52,底部中文,,0,0,0,,对大写“E”而言 会向左偏移5个像素 它现在将距离屏幕左端41个像素
Dialogue: 0,0:22:39.82,0:22:44.05,底部中文,,0,0,0,,好了 以上就是设置4个精灵位置的所有代码
Dialogue: 0,0:22:44.05,0:22:48.90,底部中文,,0,0,0,,接下来需要关注如何在每条扫描线上更新精灵的图像数据
Dialogue: 0,0:22:48.90,0:22:51.32,底部中文,,0,0,0,,请看接下来的代码
Dialogue: 0,0:22:51.32,0:22:56.86,底部中文,,0,0,0,,第一块代码只会在精灵开始显示的前一条线被执行一次
Dialogue: 0,0:22:56.86,0:23:06.86,底部中文,,0,0,0,,它完成设置精灵颜色的工作 并确保精灵图像没有被水平翻转 设置好精灵的大小和形状
Dialogue: 0,0:22:56.86,0:23:06.86,顶部注释,,0,0,0,,【译者注：REFP0和REFP1寄存器用于设置玩家精灵的水平翻转，“REF”表示“Reflect”，两个寄存器都只有第三位有效】
Dialogue: 0,0:23:06.86,0:23:14.76,底部中文,,0,0,0,,在这个例子中 玩家精灵被拉伸为每比特图像占4个像素 而飞弹精灵为2个像素宽
Dialogue: 0,0:23:06.86,0:23:14.76,顶部注释,,0,0,0,,【NUSIZ系列寄存器中位的含义可以参考雅达利2600的非官方编程指南“STELLA PROGRAMMER'S GUIDE”，于1979年发布】
Dialogue: 0,0:23:14.76,0:23:23.24,底部中文,,0,0,0,,字母“E”和“T”的高度都为16条扫描线 所以右侧代码块的循环会被执行16次
Dialogue: 0,0:23:14.76,0:23:23.24,顶部注释,,0,0,0,,【循环的次数被加载进X索引寄存器中，为0x0F即十进制的16】
Dialogue: 0,0:23:23.24,0:23:30.36,底部中文,,0,0,0,,循环的作用是从ROM里获得若干字节 并将它们写入对应的图像寄存器中
Dialogue: 0,0:23:30.36,0:23:39.02,底部中文,,0,0,0,,由于两个飞弹精灵只出现在标题文本的最后两行 它们只会在最后两次循环中被使能
Dialogue: 0,0:23:39.02,0:23:43.35,底部中文,,0,0,0,,你会注意到在循环内部有两次对WSYNC寄存器的写操作
Dialogue: 0,0:23:43.35,0:23:48.51,底部中文,,0,0,0,,这是由于两个字母的每一个基本单元都有两条扫描线的高度
Dialogue: 0,0:23:43.35,0:23:48.51,顶部注释,,0,0,0,,【译者注：“基本单元”指有立体感的字母里，精灵图像中的一个比特以相同水平偏移重复显示两条扫描线，所产生的块】
Dialogue: 0,0:23:48.51,0:23:56.51,底部中文,,0,0,0,,这些基本单元看上去像是一个“大像素” 其具有4个像素的宽度和2条扫描线的高度
Dialogue: 0,0:23:56.51,0:24:01.51,底部中文,,0,0,0,,正如之前所讲 如果前一条扫描线到下一条没有发生任何变化 则不需要写任何代码
Dialogue: 0,0:24:01.51,0:24:09.33,底部中文,,0,0,0,,在这里 一整条重复的扫描线中就只有一条DEX指令
Dialogue: 0,0:24:09.33,0:24:14.92,底部中文,,0,0,0,,当执行完这个循环的所有迭代 游戏代码中的其它部分将开始执行
Dialogue: 0,0:24:14.92,0:24:18.53,底部中文,,0,0,0,,当然也包含绘制外星人“E.T.”脸的图像
Dialogue: 0,0:24:18.53,0:24:22.85,底部中文,,0,0,0,,这一部分的精灵有48个像素宽 40个像素高
Dialogue: 0,0:24:22.85,0:24:26.15,底部中文,,0,0,0,,绘制这一部分只用到了两个玩家精灵
Dialogue: 0,0:24:26.15,0:24:33.75,底部中文,,0,0,0,,这个例子中 绘制图像的模式是在一条扫描线上将同一个精灵重复上绘制三次
Dialogue: 0,0:24:26.15,0:24:33.75,顶部注释,,0,0,0,,【译者注：通过设置上文中的NUSIZ系列寄存器，来配置精灵重复绘制的次数】
Dialogue: 0,0:24:33.75,0:24:36.50,底部中文,,0,0,0,,每次绘制间隔8个像素
Dialogue: 0,0:24:36.50,0:24:41.60,底部中文,,0,0,0,,并且两个不同玩家精灵的水平位置之间被设定了8个像素的偏移
Dialogue: 0,0:24:41.60,0:24:45.13,底部中文,,0,0,0,,这样就能够绘制总共48个像素宽的区域了
Dialogue: 0,0:24:45.13,0:24:52.07,底部中文,,0,0,0,,整个图像被分成了6x40个字节 每个8x1像素的横条被编码成一个字节
Dialogue: 0,0:24:52.07,0:24:56.12,底部中文,,0,0,0,,所有数据被存储于ROM某处的一张表里
Dialogue: 0,0:24:56.12,0:25:00.57,底部中文,,0,0,0,,由于在绘制前需要完成一些设定工作
Dialogue: 0,0:25:00.57,0:25:05.16,底部中文,,0,0,0,,负责绘制头像这个“大精灵”的代码应该提前3条扫描线开始执行
Dialogue: 0,0:25:05.16,0:25:10.66,底部中文,,0,0,0,,在第一条扫描线中 设置了两个精灵的大小和位置
Dialogue: 0,0:25:10.66,0:25:13.22,底部中文,,0,0,0,,这里对HMOVE寄存器的写操作无关紧要
Dialogue: 0,0:25:13.22,0:25:16.73,底部中文,,0,0,0,,常数0x03被载入累加器
Dialogue: 0,0:25:16.73,0:25:20.83,底部中文,,0,0,0,,常数0x00被载入Y索引寄存器
Dialogue: 0,0:25:20.83,0:25:27.48,底部中文,,0,0,0,,这两个水平翻转寄存器被清零 来保证精灵绘制时不被翻转
Dialogue: 0,0:25:27.48,0:25:29.55,底部中文,,0,0,0,,两个数量和尺寸寄存器（NUSIZ0和NUSIZ1）被写入
Dialogue: 0,0:25:29.55,0:25:35.49,底部中文,,0,0,0,,将精灵的显示模式配置为每条线重复显示3次 每次间隔8个像素
Dialogue: 0,0:25:35.49,0:25:39.80,底部中文,,0,0,0,,这一对寄存器（VDELP0和VDELP1）被写入 我们之前还没见过它们
Dialogue: 0,0:25:39.80,0:25:42.14,底部中文,,0,0,0,,它们是图形延迟寄存器
Dialogue: 0,0:25:39.80,0:25:42.14,顶部注释,,0,0,0,,【译者注：“VDEL”即表示“Vertical Delay”，在“STALLA”手册中，顾名思义理解为控制图像延迟一条扫描线写入的寄存器】
Dialogue: 0,0:25:42.14,0:25:50.61,底部中文,,0,0,0,,当这一对延迟寄存器都被清零时 向图像寄存器写入的数据将无滞后地进入对应寄存器中
Dialogue: 0,0:25:42.14,0:25:50.61,顶部注释,,0,0,0,,【编程实践和对原理图的分析都表明，“STALLA”中的理解是错误的，正确理解见视频中的解释，为“交叉控制”的延迟】
Dialogue: 0,0:25:50.61,0:25:52.69,底部中文,,0,0,0,,而当VDELP0寄存器被置位时
Dialogue: 0,0:25:52.69,0:25:55.14,底部中文,,0,0,0,,如果对0号玩家精灵的图像寄存器做写入操作
Dialogue: 0,0:25:55.14,0:26:00.30,底部中文,,0,0,0,,对于向其中写入的数据 要延迟到此后1号玩家的图像寄存器被写入时才会被真正地写入
Dialogue: 0,0:26:00.30,0:26:04.82,底部中文,,0,0,0,,这样就可以使得向两个玩家精灵的图像寄存器中写入的数据同时生效
Dialogue: 0,0:26:04.82,0:26:07.24,底部中文,,0,0,0,,同理 如果VDELP1寄存器被置位了
Dialogue: 0,0:26:07.24,0:26:13.96,底部中文,,0,0,0,,对1号玩家精灵写入的图像将延迟到0号玩家精灵的图像寄存器被写入时才生效
Dialogue: 0,0:26:07.24,0:26:13.96,顶部注释,,0,0,0,,【译者注：两个玩家精灵的图像寄存器的“交叉控制”的延迟是彼此独立的，可以选择都延迟或都不延迟，也可以只延迟某一个】
Dialogue: 0,0:26:13.96,0:26:16.52,底部中文,,0,0,0,,在这个例子中 两个延迟寄存器都被设置了
Dialogue: 0,0:26:13.96,0:26:16.52,顶部注释,,0,0,0,,【此外，还有一个控制球精灵延迟的寄存器VDELBL，与0号玩家精灵的延迟机制类似，其延迟写入行为受GRP1的触发】
Dialogue: 0,0:26:16.52,0:26:21.78,底部中文,,0,0,0,,代表着对两个玩家精灵图像寄存器真正的写入将分别发生在另一个玩家的图像寄存器被写入时
Dialogue: 0,0:26:16.52,0:26:21.78,顶部注释,,0,0,0,,【球延迟部分的原理图请参看“TIA-1A LOGIC DIAG.”中的“COLOR -LUM-PRIORITY CIRCUITS, BALL MOTION COUNTER”】
Dialogue: 0,0:26:21.78,0:26:24.39,底部中文,,0,0,0,,这样做有时序上的道理
Dialogue: 0,0:26:21.78,0:26:24.39,顶部注释,,0,0,0,,【视频中用“影子寄存器”TEMP来表达延迟写入，对应实际电路中级联的触发器，后级的时钟为对方玩家的GRP寄存器的译码信号】
Dialogue: 0,0:26:24.39,0:26:27.64,底部中文,,0,0,0,,这提供了一个字节供图形数据写入和排队等待生效的额外空位
Dialogue: 0,0:26:27.64,0:26:33.22,底部中文,,0,0,0,,使得这种在极短时间内写入6个字节的图像数据的操作变得可能
Dialogue: 0,0:26:33.22,0:26:36.97,底部中文,,0,0,0,,我将在稍后合适时再更深入地讲解这一点
Dialogue: 0,0:26:36.97,0:26:41.24,底部中文,,0,0,0,,继续来看 接下来图像寄存器都被清零 因为现在准备工作尚未完成
Dialogue: 0,0:26:41.24,0:26:47.05,底部中文,,0,0,0,,由于两个寄存器的延迟设置都已经生效 需要确保对每个寄存器写入两次来应用写入的数据
Dialogue: 0,0:26:47.05,0:26:56.36,底部中文,,0,0,0,,紧接着有一条NOP指令用来再等待2个周期 随后对两个精灵位置复位寄存器分别做写操作
Dialogue: 0,0:26:56.36,0:27:02.00,底部中文,,0,0,0,,如果我们数一数机器周期数 就能得到两个精灵分别为39个和42个周期
Dialogue: 0,0:27:02.00,0:27:08.17,底部中文,,0,0,0,,将周期数乘3 减去水平消隐期的68个像素 再加上5个像素的电子束延迟
Dialogue: 0,0:27:08.17,0:27:13.59,底部中文,,0,0,0,,就可以得到两个精灵的水平位置分别为54个像素和63个像素
Dialogue: 0,0:27:13.59,0:27:17.23,底部中文,,0,0,0,,不妙 两个精灵相隔9个像素 不而是8个像素
Dialogue: 0,0:27:17.23,0:27:23.02,底部中文,,0,0,0,,这是由于这种将数据写入对应位置复位寄存器的STA指令
Dialogue: 0,0:27:23.02,0:27:28.60,底部中文,,0,0,0,,需要花费3个周期来执行 因而产生了等效于9个像素的偏移
Dialogue: 0,0:27:28.60,0:27:33.13,底部中文,,0,0,0,,这是我们在一条扫描线上能够设置的最小精灵间隔
Dialogue: 0,0:27:33.13,0:27:39.75,底部中文,,0,0,0,,但别担心 我们将使用HM系列寄存器将第一个玩家精灵向右调整一个像素
Dialogue: 0,0:27:39.75,0:27:45.26,底部中文,,0,0,0,,放置在第55个像素的水平位置处 这样就没问题了
Dialogue: 0,0:27:45.26,0:27:51.59,底部中文,,0,0,0,,在下一条扫描线 需要在RAM里存放好指向ROM中精灵图像数据的所有指针
Dialogue: 0,0:27:51.59,0:28:00.90,底部中文,,0,0,0,,第一条指令是写HMOVE寄存器 因为对HMOVE的写操作永远应该紧跟在对WSYNC寄存器的写操作后
Dialogue: 0,0:27:51.59,0:28:00.90,顶部注释,,0,0,0,,【译者注：TIA芯片的电路和时序设计要求对HMOVE寄存器的写操作必须要在水平消隐期刚开始时就完成】
Dialogue: 0,0:28:00.90,0:28:07.09,底部中文,,0,0,0,,接下来的代码仅仅在存储“大精灵”的六列图像所用到的六个指针
Dialogue: 0,0:28:07.09,0:28:14.13,底部中文,,0,0,0,,之所以要这样做 是因为绘制头像的子程序实际上是可以绘制任意图像的通用代码
Dialogue: 0,0:28:14.13,0:28:18.35,底部中文,,0,0,0,,存好指针是调用通用子程序的前置条件
Dialogue: 0,0:28:14.13,0:28:18.35,顶部注释,,0,0,0,,【译者注：即通过内存给子程序传参】
Dialogue: 0,0:28:18.35,0:28:21.49,底部中文,,0,0,0,,第三列代码的工作是设定“大精灵”的颜色
Dialogue: 0,0:28:21.49,0:28:26.77,底部中文,,0,0,0,,并初始化循环计数器为0x27 即十进制的39
Dialogue: 0,0:28:26.77,0:28:30.57,底部中文,,0,0,0,,因为循环需要被执行40次
Dialogue: 0,0:28:30.57,0:28:36.63,底部中文,,0,0,0,,接下来有一条JSR即子程序调用指令 用来调用通用的绘制子程序
Dialogue: 0,0:28:36.63,0:28:38.85,底部中文,,0,0,0,,在这最后一条起预设定作用的扫描线结束前
Dialogue: 0,0:28:38.85,0:28:44.85,底部中文,,0,0,0,,头像最左边那一列的8个像素的图像数据被写进GRP0寄存器等待生效
Dialogue: 0,0:28:44.85,0:28:50.60,底部中文,,0,0,0,,由于图像数据的延迟寄存器被使能 写入的数据并不会立刻生效
Dialogue: 0,0:28:50.60,0:28:54.57,底部中文,,0,0,0,,但一旦GRP1寄存器被写入 写入GRP0的数据就会有效
Dialogue: 0,0:28:54.57,0:29:02.37,底部中文,,0,0,0,,顺带一提 接下来我将使用A、B、C、D、E和F来指代头像的六列对应的6字节图形数据
Dialogue: 0,0:29:02.37,0:29:09.53,底部中文,,0,0,0,,在这条扫描线后 字节A在与GRP0关联的临时寄存器中等候生效
Dialogue: 0,0:29:09.53,0:29:18.95,底部中文,,0,0,0,,最后 WSYNC寄存器被写入 我们将等待显示有头像的第一条扫描线的到来
Dialogue: 0,0:29:18.95,0:29:24.83,底部中文,,0,0,0,,现在来到了主循环 它负责在恰当的时机写入图像数据
Dialogue: 0,0:29:24.83,0:29:30.14,底部中文,,0,0,0,,基本的做法是在将所需字节在被取用之前写入
Dialogue: 0,0:29:30.14,0:29:35.94,底部中文,,0,0,0,,向图像寄存器写入数据的操作发生在写指令的最后一个机器周期
Dialogue: 0,0:29:35.94,0:29:44.19,底部中文,,0,0,0,,因此在电子束开始绘制精灵的对应部分以前 写指令就应当彻底执行完毕
Dialogue: 0,0:29:44.19,0:29:52.45,底部中文,,0,0,0,,但同时这也意味着 写指令可以在电子束还没有扫描完此玩家精灵的上一份拷贝时就开始执行
Dialogue: 0,0:29:52.45,0:29:59.59,底部中文,,0,0,0,,这是一件好事情 因为一条写指令最少要用3个机器周期或扫描9个像素的时间
Dialogue: 0,0:29:59.59,0:30:05.96,底部中文,,0,0,0,,是没有办法完全安排进同一个玩家精灵的两份拷贝绘制之间的间隙（8个像素）的
Dialogue: 0,0:30:05.96,0:30:15.42,底部中文,,0,0,0,,在了解代码实际的运作方式前 先来试一下朴素的方法 修改到能工作为止 再对比两者异同
Dialogue: 0,0:30:15.42,0:30:23.29,底部中文,,0,0,0,,假设现在图像延迟寄存器没有被使能 我们要看看为什么必须使用它们
Dialogue: 0,0:30:23.29,0:30:27.75,底部中文,,0,0,0,,为了让字节F绘制在屏幕的准确位置
Dialogue: 0,0:30:27.75,0:30:37.55,底部中文,,0,0,0,,对GRP1寄存器的第三次写入需要在电子束到达精灵这份拷贝的起始前至少1个像素时完成
Dialogue: 0,0:30:37.55,0:30:39.42,底部中文,,0,0,0,,为什么还需要提前1个像素？
Dialogue: 0,0:30:39.42,0:30:43.42,底部中文,,0,0,0,,这是由于1个机器周期等效于3个像素
Dialogue: 0,0:30:43.42,0:30:51.10,底部中文,,0,0,0,,我们无法找到一个能在任意像素处开始或结束执行的指令 而只能以每3个像素为单位对应
Dialogue: 0,0:30:51.10,0:30:56.85,底部中文,,0,0,0,,这就导致了对应于机器周期的宽3个像素的网格 对其在了如图的位置
Dialogue: 0,0:30:56.85,0:31:00.34,底部中文,,0,0,0,,如果这条写指令需要在这里结束执行
Dialogue: 0,0:31:00.34,0:31:03.95,底部中文,,0,0,0,,考虑到执行它花费3个机器周期或9个像素
Dialogue: 0,0:31:03.95,0:31:06.82,底部中文,,0,0,0,,它就必须在这里开始执行
Dialogue: 0,0:31:06.82,0:31:15.03,底部中文,,0,0,0,,这导致第三次对GRP0寄存器的写操作 写入字节E 最迟在这里开始执行
Dialogue: 0,0:31:15.03,0:31:18.97,底部中文,,0,0,0,,第二次写GRP1寄存器 写入字节D的操作 需要在这里开始
Dialogue: 0,0:31:18.97,0:31:23.91,底部中文,,0,0,0,,而必须在这里开始第二次对GRP0寄存器的写操作 写入字节C
Dialogue: 0,0:31:23.91,0:31:25.10,底部中文,,0,0,0,,我们已经触碰到了这条边界
Dialogue: 0,0:31:25.10,0:31:29.30,底部中文,,0,0,0,,但考虑到数据在写指令的最后一个周期期间才会写入
Dialogue: 0,0:31:29.30,0:31:39.24,底部中文,,0,0,0,,因此即使写入GRP0寄存器的前两个周期与0号玩家精灵的第一份拷贝重合 也完全没有问题
Dialogue: 0,0:31:39.24,0:31:45.60,底部中文,,0,0,0,,最后在这两处加上对两个图像寄存器的第一次写入
Dialogue: 0,0:31:45.60,0:31:53.12,底部中文,,0,0,0,,为了看得更清楚些 我们标出写入的精灵数据被相应地用于哪些机器周期（像素）
Dialogue: 0,0:31:53.12,0:31:58.28,底部中文,,0,0,0,,现在这么做可行 但还有一个问题
Dialogue: 0,0:31:53.12,0:31:58.28,顶部注释,,0,0,0,,【译者注：注意这里给六个精灵块实例写入数据时，都使用了来自累加器的同一个值，且累加器中的值没有变化】
Dialogue: 0,0:31:58.28,0:32:05.28,底部中文,,0,0,0,,当六个数据各不相同时 就没有办法在一行中排下这六条写指令了
Dialogue: 0,0:32:05.28,0:32:10.82,底部中文,,0,0,0,,6507 CPU内部只有三个可以存放通用数据的寄存器
Dialogue: 0,0:32:10.82,0:32:14.60,底部中文,,0,0,0,,即CPU本身只可以同时容纳3个值
Dialogue: 0,0:32:14.60,0:32:23.72,底部中文,,0,0,0,,需要在这里添加一些读指令或数据转移指令 来把六字节不同的数据在可用寄存器间快速传输
Dialogue: 0,0:32:23.72,0:32:30.67,底部中文,,0,0,0,,最易实现的是将前两个写图像寄存器的操作远远地提前到这里进行
Dialogue: 0,0:32:30.67,0:32:35.80,底部中文,,0,0,0,,并没有任何因素制约这两个操作提早完成 因为精灵还没有开始显示呢！
Dialogue: 0,0:32:35.80,0:32:41.73,底部中文,,0,0,0,,过早将前两个字节写入寄存器的这一做法并无问题
Dialogue: 0,0:32:41.73,0:32:47.60,底部中文,,0,0,0,,由于时间还很富裕 我们甚至可以在这两条写指令前各插入一条读指令
Dialogue: 0,0:32:47.60,0:32:51.47,底部中文,,0,0,0,,接下来还有4个字节的数据需要被快速转移
Dialogue: 0,0:32:51.47,0:32:58.98,底部中文,,0,0,0,,同样的 我们可以在相应精灵被绘制前将这三个字节分别装入累加器、X寄存器和Y寄存器
Dialogue: 0,0:32:58.98,0:33:02.88,底部中文,,0,0,0,,这样就为按顺序写入它们做好了准备
Dialogue: 0,0:33:02.88,0:33:05.97,底部中文,,0,0,0,,问题发生在第四个字节
Dialogue: 0,0:33:05.97,0:33:10.95,底部中文,,0,0,0,,在需要绘制前五个精灵的同时 已经容不下第四条读指令了
Dialogue: 0,0:33:05.97,0:33:10.95,顶部注释,,0,0,0,,【译者注：这里不可行是受到CPU寄存器数量限制，不能抛弃之前读到但尚未写入的字节】
Dialogue: 0,0:33:10.95,0:33:16.17,底部中文,,0,0,0,,即使我们用一条仅花费2个周期的数据转移指令
Dialogue: 0,0:33:10.95,0:33:16.17,顶部注释,,0,0,0,,【数据转移指令的作用是在CPU寄存器间交换数据】
Dialogue: 0,0:33:16.17,0:33:24.65,底部中文,,0,0,0,,并尝试用一些小技巧利用堆栈指针寄存器S来临时存放第四个数据 也都行不通
Dialogue: 0,0:33:16.17,0:33:24.65,顶部注释,,0,0,0,,【这样行不通是因为这个小技巧需要的指令数比较多，时间来不及】
Dialogue: 0,0:33:24.65,0:33:35.62,底部中文,,0,0,0,,问题出在写入字节C的指令上 它不能被更早地执行 否则就会与正在被绘制的字节A发生冲突
Dialogue: 0,0:33:35.62,0:33:40.29,底部中文,,0,0,0,,这正是我们要使能图像数据延迟寄存器的原因
Dialogue: 0,0:33:40.29,0:33:50.88,底部中文,,0,0,0,,如果可以提前将等待写入的字节写入 就能在CPU中的腾出额外的空间 充当“第四个寄存器”
Dialogue: 0,0:33:50.88,0:33:55.59,底部中文,,0,0,0,,在启用延迟写入后 将字节A写入GRP0并不会有任何效果
Dialogue: 0,0:33:55.59,0:34:01.40,底部中文,,0,0,0,,接下来把字节B写入GRP1 使得字节A被应用于精灵图像
Dialogue: 0,0:34:01.40,0:34:07.23,底部中文,,0,0,0,,紧接着写入字节C到GRP0 使得字节B生效 以此类推
Dialogue: 0,0:34:07.23,0:34:12.32,底部中文,,0,0,0,,如此 我们就可以把对GRP0的第二次写入移动到较为靠前的位置去
Dialogue: 0,0:34:12.32,0:34:16.05,底部中文,,0,0,0,,让我们可以使用累加器来暂存读取到的字节F 
Dialogue: 0,0:34:17.02,0:34:24.44,底部中文,,0,0,0,,在这第三次写入后 累加器、X和Y这三个CPU寄存器 就能排队容纳剩下的三个值了
Dialogue: 0,0:34:24.44,0:34:31.86,底部中文,,0,0,0,,我们在电子束扫描对方精灵时 有策略地写入我方精灵的图像寄存器
Dialogue: 0,0:34:31.86,0:34:39.88,底部中文,,0,0,0,,在完成全部六次写操作后 所有数据都被写入了 但最后一个字节还停留在临时的影子寄存器中没有被应用
Dialogue: 0,0:34:39.88,0:34:47.57,底部中文,,0,0,0,,为了让字节F最终被应用 我们还需要向对方寄存器 即GRP0执行一次“哑”的写操作
Dialogue: 0,0:34:47.57,0:34:56.71,底部中文,,0,0,0,,这将会使得最后一个值赶在电子束完成头像剩余精灵的绘制前及时生效
Dialogue: 0,0:34:56.71,0:35:01.11,底部中文,,0,0,0,,回看游戏代码 这就是代码中发生的一切
Dialogue: 0,0:35:01.11,0:35:05.97,底部中文,,0,0,0,,只不过相比于我们的推演 实际代码最大的区别在于
Dialogue: 0,0:35:05.97,0:35:09.47,底部中文,,0,0,0,,像这样使用指针间接地从ROM中取出数据 需要5个周期而不是2个周期
Dialogue: 0,0:35:09.47,0:35:12.28,底部中文,,0,0,0,,这使得事情变得更加困难
Dialogue: 0,0:35:12.28,0:35:18.07,底部中文,,0,0,0,,正如我们之前所见 对GRP0的第一次写入需要在上一条扫描线结束时完成
Dialogue: 0,0:35:18.07,0:35:25.90,底部中文,,0,0,0,,而对GRP1的第一次写入和对GRP0的第二次写入 需要进一步提前到当前扫描线的开始
Dialogue: 0,0:35:25.90,0:35:34.35,底部中文,,0,0,0,,在这时 两个图像寄存器分别容纳了字节A和字节B 而字节C已经在临时寄存器里就绪了
Dialogue: 0,0:35:34.35,0:35:40.03,底部中文,,0,0,0,,之后 字节D、E和F被从ROM中读出并准备好
Dialogue: 0,0:35:40.03,0:35:44.45,底部中文,,0,0,0,,事实上Y寄存器需要被征用 作为从ROM中取图像数据的索引
Dialogue: 0,0:35:44.45,0:35:46.65,底部中文,,0,0,0,,在最后我们需要把索引值覆盖掉
Dialogue: 0,0:35:46.65,0:35:50.63,底部中文,,0,0,0,,在使用累加器取数的过程中 累加器本身需要存储的数据被暂存在一个字节的内存单元中（即0x84处）
Dialogue: 0,0:35:51.26,0:35:54.57,底部中文,,0,0,0,,接下来神奇的是 无需任何多余的等待
Dialogue: 0,0:35:54.57,0:35:59.47,底部中文,,0,0,0,,字节D、E和F被写入它们对应的图像数据寄存器
Dialogue: 0,0:35:59.47,0:36:06.78,底部中文,,0,0,0,,最终 对GRP0的“哑”写入也被执行 使得字节F被真正写入图像寄存器
Dialogue: 0,0:36:06.78,0:36:12.34,底部中文,,0,0,0,,循环变量自减 跳回到循环起始处 准备下一条扫描线的绘制
Dialogue: 0,0:36:12.34,0:36:26.83,底部中文,,0,0,0,,最终在整个头像被绘制完成后 跳出循环 所有的图像数据、精灵大小设置以及图像延迟寄存器都被清零
Dialogue: 0,0:36:26.83,0:36:30.30,底部中文,,0,0,0,,再看最后一个例子 让我们回到背景上来
Dialogue: 0,0:36:30.30,0:36:34.54,底部中文,,0,0,0,,游戏《Q伯特》关卡布局中的立方体是使用背景来绘制的
Dialogue: 0,0:36:30.30,0:36:34.54,顶部注释,,0,0,0,,【译者注：《Q伯特》是一款于1982年由Gottlieb公司发行的游戏】
Dialogue: 0,0:36:30.30,0:36:34.54,顶部注释,,0,0,0,,【游戏需要玩家操纵游戏角色“Q伯特”，在躲避敌人与障碍物的同时，将方块改为目标颜色】
Dialogue: 0,0:36:34.54,0:36:40.34,底部中文,,0,0,0,,可以看到在有奇数个立方体的行中 背景因为中间那个立方体的原因而有些不对称
Dialogue: 0,0:36:40.34,0:36:47.38,底部中文,,0,0,0,,同时 背景（一行）看上去使用了3到4种颜色 而不是之前所讲的1种
Dialogue: 0,0:36:47.38,0:36:52.53,底部中文,,0,0,0,,让我们通过一条扫描线来看看这是如何实现的
Dialogue: 0,0:36:52.53,0:36:58.25,底部中文,,0,0,0,,正如同精灵和背景的图像数据能在扫描线显示的过程中被修改那样 颜色也可以被修改
Dialogue: 0,0:36:58.25,0:37:03.74,底部中文,,0,0,0,,虽然某一时刻只能使用一种颜色 但这个颜色可以随时间改变
Dialogue: 0,0:37:03.74,0:37:13.79,底部中文,,0,0,0,,所以可以使用黑底蓝色来绘制背景 也可以使用黑底黄色来绘制背景 但不能同时使用黄色和蓝色
Dialogue: 0,0:37:13.79,0:37:17.65,底部中文,,0,0,0,,COLUPF寄存器负责控制背景的颜色
Dialogue: 0,0:37:13.79,0:37:17.65,顶部注释,,0,0,0,,【译者注：“COLUPF”寄存器的全名为“Colour for Playfield”，其中高四位选择颜色，低四位中的高三位选择亮度】
Dialogue: 0,0:37:17.65,0:37:23.77,底部中文,,0,0,0,,在如图的扫描线上有三个方块 方块的颜色数据已经提前存储在内存中
Dialogue: 0,0:37:23.77,0:37:28.99,底部中文,,0,0,0,,只需要在恰当的时机将数据从内存传输到相应颜色寄存器即可
Dialogue: 0,0:37:28.99,0:37:37.30,底部中文,,0,0,0,,由于立方体反常的尺寸设计 背景寄存器中的PF2需要在扫描线绘制过程中被修改
Dialogue: 0,0:37:37.30,0:37:41.17,底部中文,,0,0,0,,这样做只是为了让中间的立方体看起来不比其它的更大
Dialogue: 0,0:37:41.17,0:37:45.18,底部中文,,0,0,0,,然而却产生了这个巨大的之字形间隙
Dialogue: 0,0:37:45.18,0:37:47.45,底部中文,,0,0,0,,寄存器在恰当的时机被修改
Dialogue: 0,0:37:47.45,0:37:53.63,底部中文,,0,0,0,,使得即使屏幕两半共享相同的图像数据 中间那个方块的两半依然能被正确显示
Dialogue: 0,0:37:53.63,0:38:01.59,底部中文,,0,0,0,,除了屏幕中间那个奇怪的间隙外 被设置为镜像模式的背景还造成了方块侧面的阴影相互矛盾的问题
Dialogue: 0,0:38:03.74,0:38:05.53,底部中文,,0,0,0,,感谢您的观看！
Dialogue: 0,0:38:05.53,0:38:23.18,版权信息,,0,0,0,,原视频信息、赞助链接以及相关开发资料已放在视频简介中
Dialogue: 0,0:38:05.53,0:38:23.18,版权信息,,0,0,0,,字幕仅供学习，如有侵权请联系删除，严禁盗用视频片段或用于盈利目的！
Dialogue: 0,0:38:05.53,0:38:23.18,版权信息,,0,0,0,,翻译：某科学的小姚同志 翻译不易，完全用爱发电，求一键三连充电加关注支持一下QwQ
Dialogue: 0,0:38:05.53,0:38:09.44,底部中文,,0,0,0,,“复古游戏机制详解”频道开通了Patreon和SubscribeStar赞助页面
Dialogue: 0,0:38:09.44,0:38:12.66,底部中文,,0,0,0,,如果可以的话 希望您慷慨解囊 支持一下本频道
Dialogue: 0,0:38:12.66,0:38:18.82,底部中文,,0,0,0,,如果没有经济条件 收看视频并留下评论 并把它分享给你的朋友们 也是对我们极大的鼓励
Dialogue: 0,0:38:18.82,0:38:23.18,底部中文,,0,0,0,,关于雅达利2600想要知道更多 请在评论区留言吧！
